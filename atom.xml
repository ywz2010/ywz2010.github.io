<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录生活~</title>
  <subtitle>ywz的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenzhao.in/"/>
  <updated>2017-02-23T12:57:48.000Z</updated>
  <id>http://wenzhao.in/</id>
  
  <author>
    <name>Yin Wenzhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qunar React Native 大规模应用实践</title>
    <link href="http://wenzhao.in/qrn-practice/"/>
    <id>http://wenzhao.in/qrn-practice/</id>
    <published>2017-02-22T12:15:00.000Z</published>
    <updated>2017-02-23T12:57:48.000Z</updated>
    
    <content type="html">&lt;p&gt;【导读】Qunar React Native（下文简称 QRN）是去哪儿网（Qunar）基于 React Native（下文简称 RN）定制的一套框架，让 RN 用起来更方便快捷，2016 年 3 月上线后已在公司内部大规模应用。透过 QRN 的大规模实践我们可以看到如何更好地去使用 RN。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文首次发表在《程序员》杂志 2017 年 02 月期，如需转载，请与《程序员》联系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;移动 App 跨平台开发技术因为可以低成本、高效率地完成 App 开发，一直以来都是移动开发的热点。目前常见的跨平台开发技术包括 React Native、Weex 和基于 HTML5 的 Hybrid 框架。Qunar 基于 React Native 定制了一套跨平台移动开发框架——Qunar React Native（QRN），QRN 与已有两年历史的 HY（基于 H5 的 Hybrid 方案）一同构成了当前 Qunar 的跨平台开发框架，这两个框架都是由 Qunar 移动架构组 YMFE 推出。&lt;/p&gt;
&lt;p&gt;QRN 解决了使用 RN 中的诸多问题，实现了更少的平台差异、更高的开发效率、更好的用户体验，也非常适合像 Qunar 内部这种多个业务隔离的开发体系。结合成熟的离线资源包框架，QRN 页面可以通过热发快速地完成线上 Bug 的修复甚至发布新页面。目前 Qunar 内部已经有大量的业务上线基于 QRN 的页面，这其中也包括了许多核心的业务流程和日均千万 PV 的页面。&lt;/p&gt;
&lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;Qunar 从 2009 年率先开始无线业务至今，移动客户端一直承担着大量的业务需求。2014、2015 年正是 Qunar 在移动端发力、业务增长凶猛的关键时期，去哪儿旅行 App 的页面也与日俱增，2015 年底 iOS 端 App 大小一度超过 110MB。由于 App Store 的限制，超过 100MB 的 App 只能在 Wi-Fi 下才能下载，这就导致了用户期望定机票、酒店时不能使用 3G/4G 网络随时下载去哪儿旅行客户端，因此当时一个迫切的需求就是减少 App 的大小。&lt;/p&gt;
&lt;p&gt;缩减 App 包大小的常见思路是去除冗余的业务、优化图片资源等，但是这样依然很难将 App 的大小减少到 100MB 以下。而从根本上减少 App 大小就需要减少 Native 的页面，删减业务显然不是一个可行的方案，这就要求我们将页面做成可以动态化配置。&lt;/p&gt;
&lt;p&gt;在 QRN 之前，Qunar 内部一直存在由我们团队推出的一套可以支持动态化配置的跨平台 App 开发框架——HY &lt;a href=&quot;http://ued.qunar.com/hy2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(点击查看更多详情)&lt;/a&gt;。HY 是基于 HTML5 的 Hybrid 开发框架，在 Qunar App 中已经有大量的业务使用该方案开发。但是 HTML5 的解决方案存在体验和性能两方面的问题，表现为基于 HY 开发的页面很难达到一个原生的用户体验，在低端 Android 机上体验差，这在一些复杂的动画场景中尤为明显。这些问题其实是 HTML5 方案的基因所决定，因此为了减少 App 的大小我们迫切需要一个新的支持动态化配置的跨平台 App 开发框架。&lt;/p&gt;
&lt;p&gt;经过一系列的调研和讨论后，我们决定尝试使用 Facebook 开源的 React Native 作为新的跨平台移动开发框架，这是因为 RN 具有以下特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持动态化：RN 的页面逻辑使用 JavaScript（下文简称 JS）来控制，因此我们可以做到动态发布。&lt;/li&gt;
&lt;li&gt;跨平台性：RN 本身是支持 iOS 和 Android 两个平台的开发。同时由于其页面开发方式是完全 Web 化的 JS 和 React，这就让 RN 的 Web 端实现成为可能（React Web 就是 QRN 的 Web 端实现），因此 RN 完全可以做到一套代码三端运行。&lt;/li&gt;
&lt;li&gt;Native 的用户体验：RN 页面使用的是 Native 的原生组件，具有更强的可定制性，完全可以做到一个 Native 的用户体验。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了验证 RN 的技术细节，2015 年 12 月我们在 Qunar 的一个热门独立客户端“去哪儿睡”上线了基于 RN 开发的酒店用户点评页，其中包括相册的选取界面都是用 RN 来完成（如图 1 所示），该项目同时上线了 iOS 和 Android，页面的整体效果超过预期，这也让我们坚信 React Native 是完全可以作为一个新的跨平台开发框架。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/588967520324d.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 1 “去哪儿睡”客户端酒店用户点评页面&lt;/center&gt;

&lt;p&gt;在上线去哪儿睡的酒店点评页的过程中，我们也发现了很多 RN 存在的问题，比如部分 RN 组件因为使用的是 Native 的组件所以还存在平台差异、打开 RN 页面时需要一个较长的加载时间等。为了解决这些问题，我们花了 3 个月的时间基于 RN 定制了一套更快、更好、更统一的跨平台开发框架 QRN。&lt;/p&gt;
&lt;h2 id=&quot;大规模应用现状&quot;&gt;&lt;a href=&quot;#大规模应用现状&quot; class=&quot;headerlink&quot; title=&quot;大规模应用现状&quot;&gt;&lt;/a&gt;大规模应用现状&lt;/h2&gt;&lt;p&gt;2016 年 3 月我们上线了第一个基于 QRN 的页面：去哪儿旅行 iOS 客户端的酒店首页。在之后的几个月中我们上线了大量基于 QRN 开发的项目，到 2016 年 10 月在去哪儿旅行客户端中已有超过 20 个 QRN 项目，其中有 14 个是同时上线了 iOS 和 Android。平均每个项目有 8 个以上的页面，在此之中，酒店一个 QRN 项目就有多达 20 个页面。&lt;/p&gt;
&lt;p&gt;在去哪儿旅行客户端中首页的酒店（仅 iOS）、客栈名宿、金融理财的一级入口均为 QRN 页面。不仅如此，对于核心业务流程，例如订单列表页、订单详情页、用户登录页面也都替换为了 QRN 页面（见图 2），这其中包含了很多日均千万 PV 的页面。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/5889676f078e1.jpg&quot; width=&quot;400&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 2  QRN 页面替换&lt;/center&gt;

&lt;h2 id=&quot;QRN-的架构特点&quot;&gt;&lt;a href=&quot;#QRN-的架构特点&quot; class=&quot;headerlink&quot; title=&quot;QRN 的架构特点&quot;&gt;&lt;/a&gt;QRN 的架构特点&lt;/h2&gt;&lt;p&gt;QRN 在去哪儿内部大规模的应用与其架构密不可分，在设计 QRN 框架时我们主要考虑了下面三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务使用的便利性：部分 RN 组件，比如 Switch、Picker 等并没有做到 iOS、Android 两端的 UI 风格统一，而在 Qunar 移动开发中要求两个平台具有一致的 UI 风格，因此为了保证业务使用的便利性，我们需要进一步抹平平台差异。&lt;/li&gt;
&lt;li&gt;与现有页面的共存：在 Qunar 移动端中不仅仅存在 Native 页面，还存在着大量 HY 页面，怎么和这些现有页面进行共存也是我们设计 QRN 所需考虑的问题。&lt;/li&gt;
&lt;li&gt;支持热发更新：RN 是一个支持动态化的移动 App 开发框架，因此我们需要考虑设计一个完善的热发更新机制来实现 QRN 页面的 bugfix 甚至提供上线新页面。&lt;br&gt;那么，我们是怎么做的呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;进一步抹平平台差异&quot;&gt;&lt;a href=&quot;#进一步抹平平台差异&quot; class=&quot;headerlink&quot; title=&quot;进一步抹平平台差异&quot;&gt;&lt;/a&gt;进一步抹平平台差异&lt;/h3&gt;&lt;p&gt;RN 的 Switch 使用的是 iOS 和 Android 各自平台的 UI 风格（如图 3 所示），这在使用时极为不便。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/58896792d356c.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;图 3  React Native 的 Switch 两端 UI 风格对比&lt;/center&gt;

&lt;p&gt;在 QRN 中我们提供了 iOS 和 Android 统一的 UI 风格，方便业务使用（如图 4 所示），对于其他不统一的基础 UI 组件，我们都在 Android 上基于 iOS 风格重新实现，保证了两个平台的 UI 统一。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/588967af5ee09.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 4  QRN 中统一的 Switch UI 风格&lt;/center&gt;

&lt;p&gt;同时，我们也使用 JS 实现了一些常见的外部 UI 组件，例如图 5 中支持侧滑操作的 ListView 和日历等组件。使用 JS 实现的组件具有很强的跨平台性，如果这些 UI 组件出现 Bug，我们也可以通过热发更新快速修复，其成本远低于修复一个 Native 的组件（从&lt;a href=&quot;http://ued.qunar.com/qrn/extraUI.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ued.qunar.com/qrn/extraUI.html&lt;/a&gt; 可查看更多的 QRN 外部 JS UI 组件）。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/588967cd4a88c.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 5  支持侧滑操作的 ListView 和日历组件演示&lt;/center&gt;

&lt;p&gt;除了 UI 上的不同，iOS 和 Android 平台的差异还体现在其他地方，其中一个不同点就是 App 状态栏。在 iOS 上从 iOS 7 开始就支持沉浸式状态栏，且高度均为 20，但是 Android 上由于系统版本和机型的不同，是否支持沉浸式状态栏、状态栏高度这些属性在写 RN 页面时都需要关注，但 RN 并没有提供一个统一的 API 去获取。对于这些差异，在 QRN 中我们都提供了统一的 API 方便业务在写 QRN 页面时可以直接获取，从而无需区分平台。&lt;/p&gt;
&lt;p&gt;通过这些方式我们真正做到了跨平台性，去哪儿旅行客户端首页的客栈名宿页面同时上线了 iOS 和 Android，其 JavaScript 代码只有 6 处 Platform 进行平台的判断，而其源于需要和 iOS、Android 现有的 Native 页面进行交互，本身两个平台的 Native 页面进行数据传递的 Scheme 会存在差异，所以需要进行平台的判断。可以说使用 QRN 进行页面的开发完全可以做到不需要平台代码的判断，一套代码同时运行在两个平台上。&lt;/p&gt;
&lt;h3 id=&quot;JS-Bundle-的拆分&quot;&gt;&lt;a href=&quot;#JS-Bundle-的拆分&quot; class=&quot;headerlink&quot; title=&quot;JS Bundle 的拆分&quot;&gt;&lt;/a&gt;JS Bundle 的拆分&lt;/h3&gt;&lt;p&gt;RN 中最终 pack 出来的 JS Bundle 文件不仅仅包含了业务的页面 JS 逻辑，还包含了 RN 组件和其框架的 JS。在 QRN 中，我们把 JS Bundle 文件拆分成了 QRN 的框架 JS 和业务 JS（如图 6 所示），在拆分后所有的业务共用一份 QRN 框架 JS，这样每个业务只需提供自己的业务 JS，通过它们的拆分，有效地减少了 JSBundle 的大小，同时也方便了后续的预加载和缓存。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/588967ebc2554.jpg&quot; width=&quot;350&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;图 6  拆分 JS Bundle&lt;/center&gt;

&lt;h3 id=&quot;QRN-的预加载和缓存&quot;&gt;&lt;a href=&quot;#QRN-的预加载和缓存&quot; class=&quot;headerlink&quot; title=&quot;QRN 的预加载和缓存&quot;&gt;&lt;/a&gt;QRN 的预加载和缓存&lt;/h3&gt;&lt;p&gt;RN 中创建 RCTRootView（RN 页面渲染的 View）之后会有一个白屏的时间等待 RN 环境的初始化和加载 JS Bundle 文件，这个时间会接近 1s。在 QRN 中，我们提供一个异步获取 RCTRootView 的方法，获取的 RCTRootView 已经完成了 RN 环境的初始化，并已加载完 QRN 的框架 JS 和业务 JS，这时可以直接开始渲染。&lt;/p&gt;
&lt;p&gt;为了减少 QRN 中获取 View 的时间，我们进行了 RN 环境的预加载和缓存。所谓预加载就是提前初始化好一个已经加载 QRN 框架 JS 的 RN 环境，这样就只需要去加载业务 JS，可以缩短最少 200ms 的等待时间。缓存指的是我们会缓存一个业务已经加载好的 RN 环境，当下次进入这个业务时就可以直接开始页面的渲染。&lt;/p&gt;
&lt;p&gt;在 QRN 中我们给每个业务提供了一个独立的 RN 环境，保证了业务的独立性，当一个业务的 JS 代码出现问题时并不会影响其他业务。这种 QRN 业务完全解耦的方式非常适合类似于 Qunar 这种业务隔离的情况。&lt;/p&gt;
&lt;h3 id=&quot;成熟的离线资源包框架&quot;&gt;&lt;a href=&quot;#成熟的离线资源包框架&quot; class=&quot;headerlink&quot; title=&quot;成熟的离线资源包框架&quot;&gt;&lt;/a&gt;成熟的离线资源包框架&lt;/h3&gt;&lt;p&gt;在 QRN 中，业务 JS 是线上资源，为了减少用户下载时间，我们给 QRN 添加了离线资源包的支持，如果其中有对应网络请求的网络资源，那么请求会直接返回本地离线资源包中的文件，这个时间和读取本地文件一样，因此有效减少了网络请求业务 JS 的时间。同时对于业务使用的图片等资源，我们也会放在离线资源包中加快资源打开速度。离线资源包的使用不仅仅减少了下载业务 JS 的时间，而且让 QRN 页面可以在离线情况下打开，更像一个 Native 的页面。&lt;/p&gt;
&lt;p&gt;目前所有的动态化移动开发框架都需要离线资源包的支持来减少资源加载时间，每个公司应该都会有自己的一套实现机制，QRN 使用的离线资源包已经在 HY 中应用多年，其基于 BSDiff 的差分更新机制和智能化的更新策略可以在保证节省用户流量的同时拥有极高的资源包更新率。一个 1.2MB 的资源包，其更新时仅仅需要下载不到 1KB 的补丁。该离线资源包框架适合加速移动开发中的各种网络资源请求，引入框架不需要对已有的网络请求代码做任何修改，整个资源包框架对于资源请求方是无感知的。&lt;/p&gt;
&lt;h3 id=&quot;自定义-IconFont（图标字体）的支持&quot;&gt;&lt;a href=&quot;#自定义-IconFont（图标字体）的支持&quot; class=&quot;headerlink&quot; title=&quot;自定义 IconFont（图标字体）的支持&quot;&gt;&lt;/a&gt;自定义 IconFont（图标字体）的支持&lt;/h3&gt;&lt;p&gt;在 QRN 中我们添加了自定义 IconFont 的支持，可以使用 IconFont 来作为图标。业务只需要在 JS 代码中配置需要加载的 IconFont 就可以自动完成字体的添加，整个过程无需编写任何 Native 代码。与使用图片做图标相比，IconFont 作为矢量图更清晰、更轻量也更灵活。&lt;/p&gt;
&lt;p&gt;图 7 所示的去哪儿旅行客栈名宿页面中的住宿类型图标就是基于 IconFont 实现，通过设置字体颜色、阴影等属性就可以控制图标的效果，如果使用图片的话就得为每个不同的大小和效果准备不同的文件。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/5889680d63d9f.jpg&quot; width=&quot;450&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 7  基于 IconFont 实现的住宿类型图标&lt;/center&gt;

&lt;p&gt;目前我们团队已经开源了 &lt;a href=&quot;http://yicon.ymfe.tech/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;YIcon&lt;/code&gt;&lt;/a&gt; ，一个集图标展示、上传、使用于一身的图标平台，如果你希望在前端、移动端项目上使用 &lt;code&gt;IconFont&lt;/code&gt; 来替换图片图标的话，欢迎使用我们提供的 IconFont 平台。&lt;/p&gt;
&lt;h3 id=&quot;无埋点统计方案支持&quot;&gt;&lt;a href=&quot;#无埋点统计方案支持&quot; class=&quot;headerlink&quot; title=&quot;无埋点统计方案支持&quot;&gt;&lt;/a&gt;无埋点统计方案支持&lt;/h3&gt;&lt;p&gt;QRN 中增加了对 Qunar 无埋点统计方案 &lt;a href=&quot;http://qav.qunar.com/static/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;QAV&lt;/a&gt; 的支持，通过修改 RN 框架，我们做到了 JS 代码无需任何修改就可以统计用户的点击、跳转数据，结合 QAV 提供的用户细查、页面流量分析等多维度的用户分析渠道，让 App 开发者可以洞察用户的行为。而引入这套无埋点方案非常简单，只需将 RN 替换为 QRN 即可，不用对已有的 RN JS 代码做任何的修改。&lt;/p&gt;
&lt;h3 id=&quot;全新的-ScrollView-和-ListView&quot;&gt;&lt;a href=&quot;#全新的-ScrollView-和-ListView&quot; class=&quot;headerlink&quot; title=&quot;全新的 ScrollView 和 ListView&quot;&gt;&lt;/a&gt;全新的 ScrollView 和 ListView&lt;/h3&gt;&lt;p&gt;ScrollView 和 ListView 是业务最常使用的两个组件，但是 RN 的 ScrollView 和 ListView 的性能和内存占用达不到我们的期望。目前网上有很多开源的优化方案，在 QRN 中我们也设计了一套全新的 ScrollView 和 ListView，可以带来更高的灵活性和更小的内存占用。&lt;/p&gt;
&lt;p&gt;QRN 的 ScrollView 与 RN ScrollView 最大的不同在于前者的滚动手势是由 JS 控制，而后者使用的是 Native 的 ScrollView，在 Native 处理了滚动手势后通知 JS ScrollView 滚动到哪个位置，详细对比可见图 8。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/588968307ebfb.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 8  QRN ScrollView 与 RN ScrollView 处理对比&lt;/center&gt;

&lt;p&gt;因为 RN 中除了 ScrollView 和 ListView 以外，其他组件的用户手势均由 JS 处理，如果使用 QRN ScrollView 则可以保证 RN 页面所有的组件都使用了统一的手势处理机制，从而带来极大的灵活性，让 ScrollView 嵌套 ScrollView 的效果更加自然。&lt;/p&gt;
&lt;p&gt;QRN 的 ListView 基于 React 的虚拟 DOM Diff 算法实现了真正意义上的 Cell 复用，图 9 显示了在 iPhone 7 上同样 2000 行数据滑动到底时的内存占用情况，可以看到 QRN 的 ListView 内存占用一直维持在 70MB 以内，而 RN 的 ListView 在滑动过程中内存最高达 1.3GB，最终稳定的内存占用也接近 600MB，显然对于大部分的机型，RN ListView 这样的内存占用会导致 App 闪退。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://ipad-cms.csdn.net/cms/attachment/201702/588968f2b93a3.jpg&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;center&gt;图 9  内存占用峰值对比&lt;/center&gt;

&lt;p&gt;QRN 的 ListView 与 RN ListView 用法完全一致，一个现有的 RN 项目只需要将 &lt;code&gt;import{ListView}from&amp;#39;react-native&amp;#39;&lt;/code&gt;修改为 &lt;code&gt;import{ListView}fromqunar-react-native&lt;/code&gt; 即可使用 QRN 的 ListView。&lt;/p&gt;
&lt;p&gt;由于 QRN 的 ScrollView 会在 JS 中处理滚动手势，QRN 的 ListView 也会在 JS 中处理 cell 的复用，因此一旦 JS 线程负担过重就会导致页面的卡顿，这也是目前 QRN ScrollView 和 ListView 存在的不足，好在其中大部分都可以通过优化 JS 代码解决。&lt;/p&gt;
&lt;h2 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h2&gt;&lt;p&gt;在大规模应用 QRN 的过程中，我们也遇到了很多问题，主要表现为：&lt;/p&gt;
&lt;h3 id=&quot;node-modules-依赖问题&quot;&gt;&lt;a href=&quot;#node-modules-依赖问题&quot; class=&quot;headerlink&quot; title=&quot;node_modules 依赖问题&quot;&gt;&lt;/a&gt;node_modules 依赖问题&lt;/h3&gt;&lt;p&gt;npm 并没有很好地解决模块依赖冲突的问题（关于 npm 处理模块依赖冲突的方式可阅读：&lt;a href=&quot;http://www.alloyteam.com/2016/03/master-npm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.alloyteam.com/2016/03/master-npm/&lt;/a&gt;）。但是在 RN 中这个情况会变得更加复杂，RN pack 包的逻辑会默认使用第一级目录下的模块，也就是说如果一个模块 A，在第一级目录下安装了版本 A@1，但是另外一个模块 B 依赖了模块 A@2，那么在模块 B 的 &lt;code&gt;node_modules&lt;/code&gt; 下会安装模块 A@2，但是 RN pack 出来的 JS Bundle 中只会存在 A@1。&lt;/p&gt;
&lt;p&gt;因为 QRN 中进行了框架 JS 和业务 JS 的拆分，而同一个模块只会在框架 JS 和业务 JS 中存在一份，这就导致了我们需要保证不同的业务 pack JS Bundle 时一级目录下 QRN 依赖的模块都是指定版本。目前，我们自定义了一套&lt;a href=&quot;http://ued.qunar.com/qrn/qrn_tool.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;工具&lt;/a&gt;来解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;React-Native-开发&quot;&gt;&lt;a href=&quot;#React-Native-开发&quot; class=&quot;headerlink&quot; title=&quot;React Native 开发&quot;&gt;&lt;/a&gt;React Native 开发&lt;/h3&gt;&lt;p&gt;RN 的开发使用了大量的前端工具，如 JSX、Redux 等。因此，一个前端开发者来开发 RN 时会更容易上手；但是 RN 的开发又需要了解 Native 的布局，这点 Native 开发者会更加熟悉。&lt;/p&gt;
&lt;p&gt;目前在 Qunar 内部，同时有前端团队和 Native 开发团队在进行 QRN 页面的开发。在我们看来，RN 的开发是一个全新的开发方式，其既不是传统的前端开发，也不能简单地当作 iOS、Android 开发。相比于前端几十年的开发历史，RN 从公布到现在还不足 2 年，关于 RN 还缺乏足够多的优化技巧与资料，匮乏的高级 RN 开发者其实也阻碍了 RN 的推广与应用，好在这个问题相信会随着越来越多的人学习 RN 开发得到改善。&lt;/p&gt;
&lt;h3 id=&quot;一直变化的官方版本&quot;&gt;&lt;a href=&quot;#一直变化的官方版本&quot; class=&quot;headerlink&quot; title=&quot;一直变化的官方版本&quot;&gt;&lt;/a&gt;一直变化的官方版本&lt;/h3&gt;&lt;p&gt;RN 目前还处于变化中，每两周会有一个新版本，从 2017 年开始，RN 的发布周期变为每个月一次，逐渐趋于稳定。版本的频繁更新特别是布局 CSS Layout 的改动，会导致现有的 Flex 布局出现问题。想象一下，一个 Web 页面在一年间要依次兼容 IE6 至 IE10，这显然是需要开发者花费大量精力来处理版本升级所带来的兼容问题。&lt;/p&gt;
&lt;p&gt;QRN 在 2016 年 10 月做了一次官方版本的同步，将基于的 RN 版本从 0.20.0 升级到了 0.33.0，升级之后需要业务进行所有页面的回归，主要是要业务解决 Flex 布局的变化可能导致页面显示错误的问题。升级的主要目的是为了解决 0.20.0 中 RN 存在的 Bug，这个过程中发现升级 Base 的 RN 版本会给业务造成负担，后续 QRN 会评估同步 RN 新版本的收益和风险来决定是否升级 Base 的 RN 版本。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h2&gt;&lt;p&gt;Qunar 一直以来就是以技术驱动的公司，敢于尝试各种新的技术，在 RN 开源后我们团队就一直在探讨 App 中引入 RN 的可行性。目前 QRN 已经在 Qunar 内部大规模应用，这也验证了我们对 RN 的看法：RN 完全可以胜任核心业务页面，虽然和 Native 的页面还存在差距，但是由于其很强的可定制性，因此潜力很大。随着越来越多更熟练的 RN 开发者出现，RN 必将在业界成为一个非常核心的移动跨平台开发方案。后续我们将把 QRN 做成一个 SDK，开放给大家使用，让 RN 的开发变得更加快捷、简单，未来也在计划开源 QRN。&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      Qunar React Native 大规模应用实践现状
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
      <category term="QunarReactNative" scheme="http://wenzhao.in/tags/QunarReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Qunar React Native ( QRN ) 首屏加载速度优化</title>
    <link href="http://wenzhao.in/qrn-optimize-load-firstPage/"/>
    <id>http://wenzhao.in/qrn-optimize-load-firstPage/</id>
    <published>2017-01-17T02:15:00.000Z</published>
    <updated>2017-01-19T13:47:04.000Z</updated>
    
    <content type="html">&lt;p&gt;React Native ( RN )可以说是目前最火的移动跨平台开发框架，其通过 JavaScript （JS）来开发 iOS、Android 原生应用，因为使用的是 Native 的原生组件，通过 RN 开发的页面可以媲美原生 Native 页面。 Qunar  React  Native ( QRN ) 是 Qunar 移动架构组 ( YMFE ) 基于 RN 深度定制的跨平台移动开发框架，QRN 在框架层面上进一步抹平了 iOS 与 Android 的平台差异，让 RN 的开发变得更加高效。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;当我们打开 RN 的 Demo 时可以非常明显的看到在显示 RN 页面之前有一个白屏的过程。为了优化体验，在 QRN 中使用了 Loading 动画对应 RN 中的白屏阶段。当点击进入一个 QRN 页面时我们会先看到 Loading 动画，在 Loading 动画结束后才会进入到 QRN 页面，这个 Loading 动画只会在用户首次进入该页面时出现。但是随着业务 QRN 的页面变得复杂，引入更多工具例如 Redux后，首屏加载的 Loading 动画时间会越来越长，用户体验也会变得更糟。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844822177784.jpg&quot; width=&quot;500&quot; title=&quot;RN 加载白屏&quot;&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844867632251.jpg&quot; width=&quot;480&quot; title=&quot;QRN 加载Loading&quot;&gt;
&lt;p&gt;本文就是为了减少 Loading 动画时间，让 QRN 页面更像一个 Native 页面。首先会介绍 RN 中一些重要概念和 RN 的加载流程，并在这个基础上介绍 QRN 中为了提高打开速度所做的一些工作， 之后会结合这些提出优化 QRN 首屏加载速度的方法，让 Loading 动画的时间变得更短。对于使用 RN 进行开发的朋友也可以通过这些方法减少白屏时间。&lt;/p&gt;
&lt;h2 id=&quot;RootView-与-Bridge&quot;&gt;&lt;a href=&quot;#RootView-与-Bridge&quot; class=&quot;headerlink&quot; title=&quot;RootView  与 Bridge&quot;&gt;&lt;/a&gt;RootView  与 Bridge&lt;/h2&gt;&lt;p&gt;RootView  与 Bridge 是 RN 开发中非常重要的两个概念。RN  页面显示的所有 View 都是放置于 RootView 上，RootView 可以理解为 RN 页面的画板，一个 RootView 上同时只能显示一个通过 JS  函数 &lt;code&gt;AppRegistry.registerComponent()&lt;/code&gt; 注册的页面。&lt;/p&gt;
&lt;p&gt;Bridge 是 RN 中 JS 代码与 Native 代码交互的桥梁， 通过 Bridge JS 代码可以调用 Native 的 API，并在 RootView 上绘制需要显示的 View。可以说 Bridge 是 RN JS 代码的解释器，一个 Ready 状态的 Bridge 包含了 RN Native 环境、JS 环境以及初始化完成的各种 RN 模块和 UI 组件。&lt;/p&gt;
&lt;p&gt;在 RN 中每个 RootView 都有与之对应的 Bridge，一个 Bridge 可以对应多个 RootView ，这些多个 RootView 因为共用的一个 Bridge 所以他们其实使用的是同一套 JS 环境，并且支持显示不同的页面。 在 RN 中 RootView 的白屏和 QRN 的 Loading 动画都是在等待其所对应的 Bridge 加载完成。&lt;br&gt;&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844851764837.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;RN-的加载流程&quot;&gt;&lt;a href=&quot;#RN-的加载流程&quot; class=&quot;headerlink&quot; title=&quot;RN 的加载流程&quot;&gt;&lt;/a&gt;RN 的加载流程&lt;/h2&gt;&lt;p&gt;在了解 RN 的加载流程之前，我们先看下一个典型的 RN 页面组件的写法。我们会先从 &lt;code&gt;react&lt;/code&gt; 和 &lt;code&gt;react-native&lt;/code&gt; 中引入所需的基本组件，页面 &lt;code&gt;Page&lt;/code&gt; 继承自 &lt;code&gt;Component&lt;/code&gt; ，在&lt;code&gt;reder()&lt;/code&gt; 函数中我们会返回需要渲染的页面，最后我们会通过 &lt;code&gt;AppRegistry.registerComponent(&amp;#39;Page&amp;#39;, () =&amp;gt; Page)&lt;/code&gt; 完成页面的注册。&lt;code&gt;AppRegistry.registerComponent(&amp;#39;Page&amp;#39;, () =&amp;gt; Page)&lt;/code&gt; 函数中第一个参数 &lt;code&gt;&amp;#39;Page&amp;#39;&lt;/code&gt; 是我们需要注册的组件名称，第二个参数 &lt;code&gt;() =&amp;gt; Page&lt;/code&gt; 是一个函数，用来返回对应的页面组件。我们可以使用 &lt;code&gt;AppRegistry.registerComponent()&lt;/code&gt; 注册多个页面。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844891074833.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;这里把 RN 的加载流程简化为 4 个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 RN 环境&lt;/li&gt;
&lt;li&gt;下载 JS Bundle&lt;/li&gt;
&lt;li&gt;运行 JS Bundle &lt;/li&gt;
&lt;li&gt;渲染页面&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844898534864.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;初始化 RN 环境主要是完成 Native 环境的初始化，包括创建 Bridge 、 Bridge 中的 JS 环境、RN 模块和各种 UI 组件。JS Bundle 是由 RN 开发工具 pack 出来的 JS 文件，其中不仅仅包含了前面提到的 RN 页面组件的 JS 代码，还有 &lt;code&gt;react&lt;/code&gt;、&lt;code&gt;react-native&lt;/code&gt; 的JS代码，如果你使用了 &lt;code&gt;Redux&lt;/code&gt; ( 这基本上是 RN 开发所必备的)等其他模块，那么他们的代码也会包含在其中。RN 非常简单的 demo 页面minify 之后的 JS  Bundle 文件有接近 700KB，所以 JS Bundle文件的下载时间是需要考虑的。在运行完 JS Bundle 之后，Native 代码会在 JS 环境中执行 &lt;code&gt;AppRegistry.runApplication( moduleName, {})&lt;/code&gt;，这个函数才是渲染页面的开始，第一个参数 &lt;code&gt;moduleName&lt;/code&gt; 用来告诉JS 环境需要渲染哪一个页面，第二个参数会包含一些页面初始化props，之后用户就可以看到 RootView 上显示的页面了。前面 3 个阶段通常会花费 1s 以上的时间，而渲染页面的时间只需要几十毫秒，不会超过 200ms。因此 RN 页面的白屏主要是为了 &lt;code&gt;AppRegistry.runApplication( )&lt;/code&gt;之前的准备工作。&lt;/p&gt;
&lt;h2 id=&quot;QRN-的加载流程&quot;&gt;&lt;a href=&quot;#QRN-的加载流程&quot; class=&quot;headerlink&quot; title=&quot;QRN 的加载流程&quot;&gt;&lt;/a&gt;QRN 的加载流程&lt;/h2&gt;&lt;p&gt;在 QRN 中我们将 JS Bundle 拆分为了QRN 框架 JS 和业务 JS 两部分，并在此基础上做了 Bridge 的预加载和缓存用来减少 QRN 页面开始渲染之前的准备时间。&lt;/p&gt;
&lt;h3 id=&quot;JS-Bundle-的拆分&quot;&gt;&lt;a href=&quot;#JS-Bundle-的拆分&quot; class=&quot;headerlink&quot; title=&quot;JS Bundle 的拆分&quot;&gt;&lt;/a&gt;JS Bundle 的拆分&lt;/h3&gt;&lt;p&gt;在 RN 的加载流程中提到，JS Bundle 中不仅仅包含 RN 页面组件的 JS 代码，还有 &lt;code&gt;react&lt;/code&gt;、&lt;code&gt;react-native&lt;/code&gt; 的JS代码以及一些引入的 JS 模块代码。在 QRN 中JS Bundle 被拆分为了 QRN 框架 JS  和业务 JS。QRN 框架 JS 中包含了 &lt;code&gt;react&lt;/code&gt;、&lt;code&gt;react-native&lt;/code&gt; 以及 QRN 增强框架 &lt;code&gt;Ext&lt;/code&gt; 的 JS 代码， 这部分是和业务无关的；业务 JS  是每个业务自己写的一些 JS 代码，包含了页面的布局逻辑、fetch 数据以及处理数据的逻辑等等，如果页面非常简单，那么业务 JS 甚至只需要几KB。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844922442682.jpg&quot; width=&quot;400&quot;&gt;
&lt;p&gt;经过 JS Bundle 的拆分后，每个业务只需要提供自己的业务 JS，所有业务使用同一份 QRN 框架 JS，这显著减少了 RN 页面需要提供的 JS 代码大小，当 APP 中同时存在多个不同 RN 业务页面时我们只需要提供一份框架 JS。&lt;/p&gt;
&lt;p&gt;经过拆分后 QRN 的加载流程在 RN 的基础上变为了 5 个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 RN 环境&lt;/li&gt;
&lt;li&gt;加载框架 JS &lt;/li&gt;
&lt;li&gt;下载业务 JS &lt;/li&gt;
&lt;li&gt;运行业务 JS&lt;/li&gt;
&lt;li&gt;渲染页面&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844924224240.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;因为框架 JS 是内置到 APP 中的，所以不需要考虑框架 JS 的下载时间，这里直接把读取框架 JS 和运行框架 JS 合并为加载框架 JS 。而对于复杂的 QRN 业务，因为包含多个页面其业务 JS 的大小甚至会超过 1MB，即使是拆分之后我们依然需要考虑下载业务 JS 的时间。&lt;/p&gt;
&lt;h3 id=&quot;Bridge-的预加载和缓存&quot;&gt;&lt;a href=&quot;#Bridge-的预加载和缓存&quot; class=&quot;headerlink&quot; title=&quot;Bridge 的预加载和缓存&quot;&gt;&lt;/a&gt;Bridge 的预加载和缓存&lt;/h3&gt;&lt;p&gt;为了进一步提高打开 QRN 页面的速度，在 QRN 中预加载和缓存了 Bridge。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844941527209.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;因为初始化 RN 环境和加载框架 JS 两个阶段与具体业务是无关的，所以可以预先初始化一个已经加载了框架 JS 的 Bridge，当打开 QRN 页面时只需要执行后面的 3 个阶段。&lt;/p&gt;
&lt;p&gt;而对于一个已经成功运行业务 JS 的 Bridge，我们可以缓存下来，当用户再次打开该业务的 QRN 页面时，我们可以使用这个缓存的 Bridge，这样可以直接开始页面的渲染。&lt;/p&gt;
&lt;p&gt;在 APP 启动时会创建一个预加载框架 JS 的 Bridge。如果首次打开一个 QRN 业务页面则使用已经预加载框架 JS 的 Bridge 去加载业务 JS ，在成功加载后会缓存这个 Bridge，然后延时创建一个预加载框架 JS 的 Bridge。如果用户再次打开该 QRN 业务的页面则可以直接使用该业务缓存的 Bridge。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844946283915.jpg&quot; width=&quot;300&quot;&gt;
&lt;p&gt;因此大部分情况下首次打开一个 QRN 页面的加载流程是下图中的情况2。只有非常极端的情况：连续打开 2 个全新 QRN 业务的页面，由于预加载的框架 JS 是延迟创建，因此第二个 QRN 业务会走完全部的 5 个阶段，即情况1。对于已经缓存的 Bridge，用户打开对应的页面时，只需要进行页面的渲染，前面提到过这个时间是非常快的。QRN 中 Loading动画的时间对应下图中的红色方框，因此在 QRN 中 Loading 动画只会存在于首次进入 QRN 业务的时候。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844950632803.jpg&quot; width=&quot;600&quot;&gt;
&lt;h3 id=&quot;QRN-Loading-时间&quot;&gt;&lt;a href=&quot;#QRN-Loading-时间&quot; class=&quot;headerlink&quot; title=&quot;QRN  Loading 时间&quot;&gt;&lt;/a&gt;QRN  Loading 时间&lt;/h3&gt;&lt;p&gt;QRN 中首屏加载 Loading 动画是 QRN 页面加载流程的前面 4 个阶段，下图是我们基于 iPhone 6 测试出来的时间：&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14844955591500.jpg&quot; width=&quot;500&quot;&gt;
&lt;p&gt;通过预加载， QRN 的加载时间可以减少 300ms 左右。而下载业务 JS 又分为走离线包和走线上两种情况，走离线包指的是网络请求被本地离线资源包所拦截，这个速度和读取本地文件一致，而走线上就是由线上的服务器返回所需要的资源，随着业务 JS 大小增加，这个时间会普遍大于 1s。对于 QRN 已经上线的业务，运行业务 JS 的时间在优化之前普遍会超过 300ms。&lt;/p&gt;
&lt;h2 id=&quot;QRN-的首屏加载速度优化&quot;&gt;&lt;a href=&quot;#QRN-的首屏加载速度优化&quot; class=&quot;headerlink&quot; title=&quot;QRN 的首屏加载速度优化&quot;&gt;&lt;/a&gt;QRN 的首屏加载速度优化&lt;/h2&gt;&lt;p&gt;前面已经分析了 QRN 的加载流程和首屏 Loading 中各个阶段的时间，可以看到 QRN 的 Loading 大部分对应下载业务 JS 和运行业务 JS 两个阶段。下载业务 JS  只要保证是走离线包，那么这个时间就非常理想，因此要优化首屏加载时间就只有从运行业务 JS 入手。&lt;/p&gt;
&lt;p&gt;那么怎么来减少运行业务 JS 的时间呢，首先看看 RN 是怎么减少运行 JS Bundle 的时间的。&lt;/p&gt;
&lt;h3 id=&quot;RN-通过-Lazy-requires-优化-JS-Bundle-运行速度&quot;&gt;&lt;a href=&quot;#RN-通过-Lazy-requires-优化-JS-Bundle-运行速度&quot; class=&quot;headerlink&quot; title=&quot;RN 通过 Lazy requires 优化 JS Bundle 运行速度&quot;&gt;&lt;/a&gt;RN 通过 Lazy requires 优化 JS Bundle 运行速度&lt;/h3&gt;&lt;p&gt;Facebook 有一篇关于 RN 优化的&lt;a href=&quot;https://code.facebook.com/posts/895897210527114/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Blog&lt;/a&gt;，其中提到一个非常关键的点就是: Lazy requires，只有使用一个 JS 模块时才去 require 这个模块，基于这个原理，RN 中使用的各种组件是通过 get 的方式挂在 &lt;code&gt;react-native&lt;/code&gt; 上，这样只有用户在使用这个组件例如 &lt;code&gt;Image&lt;/code&gt; 时才会 &lt;code&gt;require(&amp;#39;Image&amp;#39;)&lt;/code&gt; 这个模块。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//  Libraries/react-native/react-native.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const ReactNative = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // Components&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get ActivityIndicator() &amp;#123; return require(&amp;apos;ActivityIndicator&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get ActivityIndicatorIOS() &amp;#123; return require(&amp;apos;ActivityIndicatorIOS&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get ART() &amp;#123; return require(&amp;apos;ReactNativeART&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get DatePickerIOS() &amp;#123; return require(&amp;apos;DatePickerIOS&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get DrawerLayoutAndroid() &amp;#123; return require(&amp;apos;DrawerLayoutAndroid&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get Image() &amp;#123; return require(&amp;apos;Image&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get ImageEditor() &amp;#123; return require(&amp;apos;ImageEditor&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get ImageStore() &amp;#123; return require(&amp;apos;ImageStore&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get KeyboardAvoidingView() &amp;#123; return require(&amp;apos;KeyboardAvoidingView&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get ListView() &amp;#123; return require(&amp;apos;ListView&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  get MapView() &amp;#123; return require(&amp;apos;MapView&amp;apos;); &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; Lazy requires 可以有效的减少运行 JS Bundle 的时间，这是因为 require 一个模块是一个耗时的操作，通过 require 的 polyfills 实现可以看到，require 会初始化一个模块并创建所需的对象，同时初始化一个模块时可能会去 require 其他模块，这种链式的 require 会导致需要花费一个较长的时间。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// packager/react-pakager/src/Resolve/polyfills/require.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function require(id) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var mod = modules[id];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if (mod &amp;amp;&amp;amp; mod.isInitialized) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return mod.module.exports;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return requireImpl(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;global.require = require;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 另一方面我们可以看到 require 函数只会初始化一次该模块，这意味着当我们多次去 require 同一个模块时，其实获取的是同一个对象实例。只有第一次 require 会花费较长时间，后面的多次 require 仅仅是简单的指针赋值，而指针赋值的速度是非常快的。&lt;/p&gt;
&lt;h3 id=&quot;QRN-框架-JS-提前-require-常用组件&quot;&gt;&lt;a href=&quot;#QRN-框架-JS-提前-require-常用组件&quot; class=&quot;headerlink&quot; title=&quot;QRN 框架 JS 提前 require 常用组件&quot;&gt;&lt;/a&gt;QRN 框架 JS 提前 require 常用组件&lt;/h3&gt;&lt;p&gt;结合前面对 require 的分析，如果在框架 JS 中提前 require 业务 JS 所需要的组件，那么业务 require 这些组件的时候只会花费非常少的时间，这样就可以显著的减少运行业务 JS 的时间，从而优化首屏加载速度。&lt;/p&gt;
&lt;p&gt;按照这个思路我们在 QRN 的框架 JS 中 require 了常用的组件，这其中包括了 &lt;code&gt;View&lt;/code&gt; 、&lt;code&gt;Text&lt;/code&gt;、&lt;code&gt;Image&lt;/code&gt;、&lt;code&gt;ScrollView&lt;/code&gt;、&lt;code&gt;ListView&lt;/code&gt; 还有 QRN 增强框架 Ext 等等。通过这种方法加载框架 JS 的运行时间增加了200ms，但是业务 JS 的运行时间相应的减少了 200ms，也就是说首屏的加载时间（对应下载业务 JS 和运行业务 JS 两个阶段）相应的也减少了 200ms。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14845605379982.jpg&quot; width=&quot;500&quot;&gt;
&lt;h3 id=&quot;异步-require-页面减少运行业务-JS-时间&quot;&gt;&lt;a href=&quot;#异步-require-页面减少运行业务-JS-时间&quot; class=&quot;headerlink&quot; title=&quot;异步 require 页面减少运行业务 JS 时间&quot;&gt;&lt;/a&gt;异步 require 页面减少运行业务 JS 时间&lt;/h3&gt;&lt;p&gt;在框架 JS 中提前 require 常用组件可以减少运行业务 JS 的时间，但是对于拥有多个页面的 QRN 业务，例如有20个页面的酒店业务，运行其业务 JS 的时间还是会超过 500ms，对于这种情况就需要通过异步 require 页面的方式来减少运行业务 JS 的时间。&lt;/p&gt;
&lt;p&gt;对于常见的 QRN 业务，其入口 JS 如下图所示，通常会先 import 基础组件，然后引入一些工具例如 Redux等，之后会 import 写在其他文件中的页面，最后我们会调用 &lt;code&gt;AppRegistry.registerComponent()&lt;/code&gt; 注册页面。import 函数是 ES6 提供的引入组件的新方式，其等效于在文件最前 require 所需的组件。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14845620112962.jpg&quot; width=&quot;600&quot;&gt;
&lt;p&gt;当运行业务 JS 时，其实初始化了所有的页面，但是一个 QRN 业务的首屏只需要一个页面，因此 require 初始化其他页面所花费的时间也就没有意义。如果可以在运行业务 JS 时不加载页面则会显著的减少运行业务 JS 的时间。由 RN 加载流程可知，&lt;code&gt;AppRegistry.registerComponent()&lt;/code&gt; 函数中第二个参数是一个函数，这个函数用来开始渲染时返回所对应的组件,如果把 require 组件写在这个函数中则可以保证在运行业务 JS 时不初始化这个组件，页面的 require 只有在需要渲染这个页面时执行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 之前的写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const Page1  = require(&amp;apos;Page1&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const Page2  = require(&amp;apos;Page2&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const Page3  = require(&amp;apos;Page3&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const Page4  = require(&amp;apos;Page4&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page1&amp;apos;, () =&amp;gt; Page1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page2&amp;apos;, () =&amp;gt; Page2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page3&amp;apos;, () =&amp;gt; Page3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page4&amp;apos;, () =&amp;gt; Page4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 优化的写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page1&amp;apos;, () =&amp;gt; require(&amp;apos;Page1&amp;apos;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page2&amp;apos;, () =&amp;gt; require(&amp;apos;Page2&amp;apos;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page3&amp;apos;, () =&amp;gt; require(&amp;apos;Page3&amp;apos;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AppRegistry.registerComponent(&amp;apos;Page4&amp;apos;, () =&amp;gt; require(&amp;apos;Page4&amp;apos;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;按照这个思路优化后 Hotel 20 个页面的业务JS 加载的时间从 500ms+ 减少到了 112ms，从下面的优化效果中可以看到影响运行 JS 的时间的关键并不是 JS 文件的大小。&lt;/p&gt;
&lt;img src=&quot;http://ojvik2xpf.bkt.clouddn.com/14845667355580.jpg&quot; width=&quot;400&quot;&gt;
&lt;p&gt;对于使用 QRN 增加框架 Ext 开发的业务，从 QRN v1.6.0 开始也提供了类似的注册方法用来优化加载速度。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; // 之前的写法，直接 require 页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;require(&amp;apos;./views/hotelList&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;require(&amp;apos;./views/hotelDetail&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // 优化的写法，第一个参数是 View Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ext.registerView( &amp;apos;HotelList&amp;apos; , ()=&amp;gt; require(&amp;apos;./views/hotelList&amp;apos;) );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ext.registerView( &amp;apos;HotelDetail&amp;apos;, ()=&amp;gt; require(&amp;apos;./views/hotelDetail&amp;apos;) );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要介绍了 RN 和 QRN 的加载流程，基于 require 组件会耗费时间的认知上提供了优化 QRN 首屏加载速度的方法：在框架 JS 中提前 require 所需的组件和在业务JS 中异步 require 页面。结合这两种方法可以有效的减少首屏的加载时间，让首次进入 QRN 页面的体验更接近 Native 页面。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      优化 QunarReactNative 首屏加载速度
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
      <category term="QunarReactNative" scheme="http://wenzhao.in/tags/QunarReactNative/"/>
    
  </entry>
  
  <entry>
    <title>textInputMaxLength</title>
    <link href="http://wenzhao.in/RN-TextInput-MaxLength/"/>
    <id>http://wenzhao.in/RN-TextInput-MaxLength/</id>
    <published>2016-05-21T08:29:06.000Z</published>
    <updated>2016-05-21T09:58:27.000Z</updated>
    
    <content type="html">&lt;p&gt;有业务线的同事提到&lt;code&gt;ReactNative&lt;/code&gt;的&lt;code&gt;TextInput&lt;/code&gt;组件存在一个bug，中文输入法通过不停点击联想词语可以突破&lt;code&gt;MaxLength&lt;/code&gt;属性的限制。于是开始研究修复这个bug。&lt;/p&gt;
&lt;h2 id=&quot;找出bug的原因&quot;&gt;&lt;a href=&quot;#找出bug的原因&quot; class=&quot;headerlink&quot; title=&quot;找出bug的原因&quot;&gt;&lt;/a&gt;找出bug的原因&lt;/h2&gt;&lt;p&gt;要修复bug首先需要确认bug出现的条件，测试发现只有使用&lt;code&gt;iOS&lt;/code&gt;系统默认的中文&lt;strong&gt;拼音&lt;/strong&gt;输入法的联想功能才会突破&lt;code&gt;TextInput&lt;/code&gt;的&lt;code&gt;MaxLength&lt;/code&gt;限制。其他输入法比如默认的中文笔画输入、搜狗输入法等都不会出现这种情况。   &lt;/p&gt;
&lt;p&gt;查看&lt;code&gt;ReactNative&lt;/code&gt;的源码发现，限制&lt;code&gt;TextInput&lt;/code&gt;输入长度的是在&lt;code&gt;RCTTextFieldManager&lt;/code&gt;对每个&lt;code&gt;RCTTextField&lt;/code&gt;的下列回调中处理的：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)textField:(RCTTextField *)textField shouldChangeCharactersInRange:(&lt;span class=&quot;built_in&quot;&gt;NSRange&lt;/span&gt;)range replacementString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Only allow single keypresses for onKeyPress, pasted text will not be sent.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (textField.textWasPasted) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    textField.textWasPasted = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [textField sendKeyValueForString:string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (textField.maxLength == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; || [string isEqualToString:&lt;span class=&quot;string&quot;&gt;@&quot;\n&quot;&lt;/span&gt;]) &amp;#123;  &lt;span class=&quot;comment&quot;&gt;// Make sure forms can be submitted via return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; allowedLength = textField.maxLength.integerValue - textField.text.length + range.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (string.length &amp;gt; allowedLength) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (string.length &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Truncate the input string so the result is exactly maxLength&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *limitedString = [string substringToIndex:allowedLength];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;NSMutableString&lt;/span&gt; *newString = textField.text.mutableCopy;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [newString replaceCharactersInRange:range withString:limitedString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      textField.text = newString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Collapse selection at end of insert to match normal paste behavior&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UITextPosition&lt;/span&gt; *insertEnd = [textField positionFromPosition:textField.beginningOfDocument&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                          offset:(range.location + allowedLength)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      textField.selectedTextRange = [textField textRangeFromPosition:insertEnd toPosition:insertEnd];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [textField textFieldDidChange];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当使用默认的中文拼音的联想输入的时候，并不会走这个&lt;code&gt;delegate&lt;/code&gt;，这个应该是算系统的bug吧，因为测试发现&lt;code&gt;UITextFieldDelegate&lt;/code&gt;的所有方法在此时均不会调用，因此使用&lt;code&gt;UITextFieldDelegate&lt;/code&gt;并不能去限制默认中文输入法的联想输入长度。   &lt;/p&gt;
&lt;p&gt;看来只有从另外的渠道去判断输入的字符是否超过长度，好在这种情况会触发&lt;code&gt;UIControlEventEditingChanged&lt;/code&gt;，因此可以在&lt;code&gt;RCTTextField&lt;/code&gt;的&lt;code&gt;textFieldDidChange&lt;/code&gt;方法中限制输入的长度，如果输入的长度过长则截取。&lt;/p&gt;
&lt;h2 id=&quot;另外的问题&quot;&gt;&lt;a href=&quot;#另外的问题&quot; class=&quot;headerlink&quot; title=&quot;另外的问题&quot;&gt;&lt;/a&gt;另外的问题&lt;/h2&gt;&lt;h3 id=&quot;拼音输入的长度问题&quot;&gt;&lt;a href=&quot;#拼音输入的长度问题&quot; class=&quot;headerlink&quot; title=&quot;拼音输入的长度问题&quot;&gt;&lt;/a&gt;拼音输入的长度问题&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;RCTTextField&lt;/code&gt;的&lt;code&gt;textFieldDidChange&lt;/code&gt;方法中限制输入的长度，可以解决默认中文联想输入过长的问题，但是自己测试就发现了另外的问题😳&lt;br&gt;中文输入的时候打的拼音会被算到&lt;code&gt;text&lt;/code&gt;的长度中，这样就导致了如果只能输入一个字符的时候只能打一个拼音字母了😂&lt;/p&gt;
&lt;p&gt;网上搜索发现中文的blog对限制&lt;code&gt;UITextField&lt;/code&gt;长度的时候都考虑过拼音字母的问题，不会统计拼音字母到字符的长度中。&lt;/p&gt;
&lt;h3 id=&quot;表情截取的问题😃&quot;&gt;&lt;a href=&quot;#表情截取的问题😃&quot; class=&quot;headerlink&quot; title=&quot;表情截取的问题😃&quot;&gt;&lt;/a&gt;表情截取的问题😃&lt;/h3&gt;&lt;p&gt;还有个关键的问题就是表情的截取问题，每个表情😄都是占用的2个字符，简单粗暴的截取就会悲剧😱&lt;/p&gt;
&lt;p&gt;网上都有很多这种类型的blog，只能说下面的这个方法真好使：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//不使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.text = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.text substringToIndex:_maxLength.unsignedIntegerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSRange&lt;/span&gt; range = &lt;span class=&quot;built_in&quot;&gt;NSMakeRange&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, _maxLength.unsignedIntegerValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSRange&lt;/span&gt; textRange = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.text rangeOfComposedCharacterSequencesForRange:range];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.text = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.text substringWithRange:textRange];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;另外的坑&quot;&gt;&lt;a href=&quot;#另外的坑&quot; class=&quot;headerlink&quot; title=&quot;另外的坑&quot;&gt;&lt;/a&gt;另外的坑&lt;/h3&gt;&lt;p&gt;当然官方的还有大坑，在判断输入字符的是否超过的限制的时候，&lt;code&gt;allowedLength&lt;/code&gt;是这样求的：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; allowedLength = textField.maxLength.integerValue - textField.text.length + range.length;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;allowedLength&lt;/code&gt;因为是无符号的，所以本来应该是负数的会变的很大很大好么😂&lt;br&gt;如果&lt;code&gt;TextInput&lt;/code&gt;默认设置字符的长度超过了&lt;code&gt;MaxLength&lt;/code&gt;，然后就可以各种玩耍输入了😂&lt;/p&gt;
&lt;p&gt;修这个问题的时候一定得注意如果默认字符超出长度的话得允许删除，不要问我为啥知道😂😂😂&lt;/p&gt;
</content>
    
    <summary type="html">
    
      修改ReactNative的TextInput组件MaxLength错误
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>折腾Hexo的第一天</title>
    <link href="http://wenzhao.in/first-hexo-day/"/>
    <id>http://wenzhao.in/first-hexo-day/</id>
    <published>2016-05-15T03:55:33.000Z</published>
    <updated>2016-05-15T11:01:34.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;hexo&lt;/code&gt;支持&lt;code&gt;Markdown&lt;/code&gt;，写起来还是蛮顺手的，不过也是各种坑啊@_@   &lt;/p&gt;
&lt;p&gt;一个网页首先少不了的就是图片了&lt;/p&gt;
&lt;p&gt;图片很好说啊，直接&lt;code&gt;Markdown&lt;/code&gt;都有现成的格式引入，&lt;code&gt;hexo&lt;/code&gt;用的是&lt;code&gt;marked&lt;/code&gt;，这个并不支持设置图片的 size，自己不想去手动压缩图片，于是首先想到就是添加对图片 size 设置的支持。&lt;/p&gt;
&lt;h2 id=&quot;图片size的支持&quot;&gt;&lt;a href=&quot;#图片size的支持&quot; class=&quot;headerlink&quot; title=&quot;图片size的支持&quot;&gt;&lt;/a&gt;图片size的支持&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;marked&lt;/code&gt;的 &lt;a href=&quot;https://github.com/chjj/marked/issues/339&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;issues&lt;/a&gt; 中 isiahmeadows 提到了一种去修改&lt;code&gt;Renderer.prototype.image&lt;/code&gt; 这个方法，增加对 size 的解析，然后根据 size 解析出来的参数去设置 &lt;code&gt;img&lt;/code&gt;标签的&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;height&lt;/code&gt;。&lt;br&gt;这个思路不错，copy了他的代码，修改了些许的bug😃，然后重启 &lt;code&gt;hexo&lt;/code&gt;的server，发现图片的&lt;code&gt;height&lt;/code&gt;属性并不能生效😓&lt;br&gt;搜索了下发现是CSS的原因， &lt;code&gt;height&lt;/code&gt;被设置为&lt;code&gt;auto&lt;/code&gt;了&lt;br&gt;其实通常情况下都不会去更改图片的长宽比，那么只需要设置下图片的&lt;code&gt;width&lt;/code&gt;就可以了，于是继续修改&lt;code&gt;markded&lt;/code&gt;，修改设置size的数值的顺序，第一个是width第二个是height。同时修改了下该代码中的解析长宽的正则，可以只写&lt;code&gt;width&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//原始的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; exec = &lt;span class=&quot;regexp&quot;&gt;/\s=\s*(\d*)\s*x\s*(\d*)\s*$/&lt;/span&gt;.exec(href)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//修改后的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; exec = &lt;span class=&quot;regexp&quot;&gt;/\s=\s*(\d*)\s*x?\s*(\d*)\s*$/&lt;/span&gt;.exec(href)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;后面就是开心的只用设置图片的宽度啦~~~&lt;br&gt;赶紧写了第一篇试试，看上去还不错~&lt;/p&gt;
&lt;p&gt;然后从首页点进去，发现了另外的一个坑。&lt;/p&gt;
&lt;h2 id=&quot;图片路径的问题&quot;&gt;&lt;a href=&quot;#图片路径的问题&quot; class=&quot;headerlink&quot; title=&quot;图片路径的问题&quot;&gt;&lt;/a&gt;图片路径的问题&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Markdown&lt;/code&gt;中图片的&lt;code&gt;src&lt;/code&gt;都是和用户写的一样，于是就出现了一个问题，在首页可以显示的图片到了详情页就不能显示了。&lt;br&gt;如果开启了&lt;code&gt;post_asset_folder&lt;/code&gt;的设置，就是详情页可以显示首页不能了。&lt;br&gt;于是继续找文档，发现使用&lt;a href=&quot;https://hexo.io/zh-cn/docs/asset-folders.html#相对路径引用的标签插件&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;相对路径引用的标签&lt;/a&gt;可以解决这个问题。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;% asset_img   icon.png 图标 %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;img src=&quot;/first-hexo-day/icon.png&quot; alt=&quot;图标&quot; title=&quot;图标&quot;&gt;
&lt;p&gt;之后就发现一个尴尬的问题，不能设置图片的大小！！！ 前面又白干了。&lt;br&gt;搜索了下发现&lt;code&gt;asset_img&lt;/code&gt;并不支持设置图片大小，于是想学着前面修改&lt;code&gt;Markdown&lt;/code&gt;的方法去修改。&lt;/p&gt;
&lt;p&gt;为了方便自己就只支持&lt;code&gt;width&lt;/code&gt;的设置了，于是首先的问题就是参数放在哪？！因为&lt;code&gt;width&lt;/code&gt;的设置不是必需的，因此就得考虑如何兼容没有设置该属性的时候。如果放在后面的话，官方的代码逻辑会把后面所有的都当成&lt;code&gt;title&lt;/code&gt;，这个逻辑是合理的，因为有的时候我们的&lt;code&gt;title&lt;/code&gt;会包含空格。&lt;br&gt;&lt;code&gt;width&lt;/code&gt;不能放后面的话就放在前面吧，考虑到一个图片的&lt;code&gt;src&lt;/code&gt;不会是纯数字的情况，因此可以通过正则判断的方式来判断第一个参数是否是&lt;code&gt;width&lt;/code&gt;还是&lt;code&gt;src&lt;/code&gt;，于是做了如下的修改：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&#39;use strict&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; url = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;url&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Asset image tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Syntax:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *   &amp;#123;% asset_img slug [title]%&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ctx&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; PostAsset = ctx.model(&lt;span class=&quot;string&quot;&gt;&#39;PostAsset&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assetImgTag&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; slug = args.shift();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//宽度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; width;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;regexp&quot;&gt;/^\d+$/&lt;/span&gt;.test(slug)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            width = slug;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            slug = args.shift();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!slug) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; asset = PostAsset.findOne(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            post: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._id,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            slug: slug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!asset) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// if title is not assigned, set it &#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; title = args.length ? args.join(&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;) : &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// alt always exist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; alt = title || asset.slug;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (width) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;img src=&quot;&#39;&lt;/span&gt; + url.resolve(ctx.config.root, asset.path) + &lt;span class=&quot;string&quot;&gt;&#39;&quot; alt=&quot;&#39;&lt;/span&gt; + alt + &lt;span class=&quot;string&quot;&gt;&#39;&quot; title=&quot;&#39;&lt;/span&gt; + title + &lt;span class=&quot;string&quot;&gt;&#39;&quot; width=&quot;&#39;&lt;/span&gt; + width + &lt;span class=&quot;string&quot;&gt;&#39;&quot;&amp;gt;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;img src=&quot;&#39;&lt;/span&gt; + url.resolve(ctx.config.root, asset.path) + &lt;span class=&quot;string&quot;&gt;&#39;&quot; alt=&quot;&#39;&lt;/span&gt; + alt + &lt;span class=&quot;string&quot;&gt;&#39;&quot; title=&quot;&#39;&lt;/span&gt; + title + &lt;span class=&quot;string&quot;&gt;&#39;&quot;&amp;gt;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;后面就可以愉快的设置图片的size了&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;% asset_img  20  icon.png 小图标 %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;img src=&quot;/first-hexo-day/icon.png&quot; alt=&quot;小图标&quot; title=&quot;小图标&quot; width=&quot;20&quot;&gt;
</content>
    
    <summary type="html">
    
      修改hexo支持图片的size
    
    </summary>
    
      <category term="Web" scheme="http://wenzhao.in/categories/Web/"/>
    
    
      <category term="hexo" scheme="http://wenzhao.in/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇</title>
    <link href="http://wenzhao.in/hello-world/"/>
    <id>http://wenzhao.in/hello-world/</id>
    <published>2016-05-14T10:30:13.000Z</published>
    <updated>2016-05-15T11:01:48.000Z</updated>
    
    <content type="html">&lt;p&gt;上午本来准备折腾下 &lt;code&gt;hexo&lt;/code&gt;的，结果在刷完6.0的Z3后没有拿稳，然后就悲剧了(＞﹏＜)&lt;br&gt;&lt;img src=&quot;/hello-world/images/z3_screen.jpg&quot; alt=&quot;破碎的屏幕💔&quot; title=&quot;破碎的屏幕💔&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;p&gt;之后就是拆机评估换屏的难度了，发现z3都开始使用热管了&lt;br&gt;&lt;img src=&quot;/hello-world/images/z3_inside.jpg&quot; alt=&quot;热管散热&quot; title=&quot;热管散热&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;p&gt;x宝买了个A屏，等收到货后看能否装起来吧。。。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      大法Z3都没有熬过一年😳
    
    </summary>
    
      <category term="Life" scheme="http://wenzhao.in/categories/Life/"/>
    
    
      <category term="life" scheme="http://wenzhao.in/tags/life/"/>
    
  </entry>
  
</feed>
