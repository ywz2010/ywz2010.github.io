<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录生活~</title>
  <subtitle>ywz的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenzhao.in/"/>
  <updated>2017-07-07T15:23:49.000Z</updated>
  <id>http://wenzhao.in/</id>
  
  <author>
    <name>Yin Wenzhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac 系统 ReactNative 开发环境的搭建</title>
    <link href="http://wenzhao.in/mac-rnDev-Environment/"/>
    <id>http://wenzhao.in/mac-rnDev-Environment/</id>
    <published>2017-07-01T12:15:00.000Z</published>
    <updated>2017-07-07T15:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于换了环境，所以需要重新配置下 Mac 系统的 React Native （后面简称为 RN）开发环境，在此就记录下怎么搭建一个舒服好用的 RN 开发环境。</p>
<p>目前自己使用的是 VS Code 作为开发的 IDE，RN 开发环境需要 Git、Node、watchman 和开发的IDE等等，因此就是按照这个顺序一步步介绍怎么搭建环境。</p>
<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>首先需要安装  <code>Homebrew</code>，<code>Homebrew</code> 是 Mac 系统的软件包管理器，可以方便的帮助我们安装所需的各种软件，一条指令就可以一键安装并配置软件所需的环境，节省了大量的时间。大家可以去 <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external"><code>Homebrew</code>官网</a> 了解更多信息。</p>
<p>在终端中输入下面指令安装 <code>Homebrew</code> ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div></pre></td></tr></table></figure></p>
<p>安装成功后终端会提示如下，到此 <code>Homebrew</code> 的安装就成功了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-83f4963bb094486e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用指令 <code>brew --version</code> 可以输出 <code>Homebrew</code> 的版本。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-a057032a9eb754f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果终端提示没有 <code>brew</code>，就需要让终端重新加载下配置文件。重启终端或者让终端重新加载配置，如果使用的是 Bash 终端输入 <code>source ~/.bash_profile</code>，使用的是 zsh 终端就输入 <code>source ~/.zshrc</code>。</p>
<p>使用指令 <code>brew install  xxx</code> 就可以安装指定的软件，后面 Git 就可以使用 <code>Homebrew</code><br> 安装。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Mac 系统默认是自带 Git ，但是一般都不是最新的版本。<br>如果我们想使用到最新版本的Git 可以使用 <code>Homebrew</code> 来安装或者去<a href="https://git-scm.com/" target="_blank" rel="external">Git官网</a>下载最新的版本安装。</p>
<h3 id="使用-Homebrew-安装-Git"><a href="#使用-Homebrew-安装-Git" class="headerlink" title="使用 Homebrew 安装 Git"></a>使用 <code>Homebrew</code> 安装 Git</h3><p>在终端中输入<code>brew install git</code> 就可以安装 Git，是不是很简单😊~ 安装完成后我们可以使用 <code>git --version</code> 来查看安装的 Git 版本。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-28e40b7897aeb5a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="使用Git-官网安装包安装"><a href="#使用Git-官网安装包安装" class="headerlink" title="使用Git 官网安装包安装"></a>使用Git 官网安装包安装</h3><p>打开从<a href="https://git-scm.com/" target="_blank" rel="external">官网</a>下载的 dmg 安装文件 <code>git-xxxx-intel-universal-mavericks.dmg</code>，双击图示的 pkg 文件一路点击下去就可以安装完成，这个过程也是很简单的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-25ed36e22000d145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 全名是 Node.js ，是一个基于<a href="https://developers.google.com/v8/" target="_blank" rel="external">Chrome V8 引擎</a>的 JavaScript 运行时。在 Node 之前 JavaScript 是运行在浏览器环境中的，Node 的出现让我们可以在后台服务器或者终端上运行 JavaScript 代码，RN 开发所使用的本地服务器就是基于 Node 实现的。</p>
<p>在 Node 的<a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">中文官网</a>中可以下载到 Node 的安装包，但是我并不推荐使用这个方式来安装。因为 Node 版本更新很快，有时候我们会在不同 Node 版本环境下进行开发，所以我们需要一个 Node 的安装工具方便以后升级和切换不同的 Node 版本，这里推荐使用 nvm 来安装 Node，在<a href="https://github.com/creationix/nvm" target="_blank" rel="external">这里</a> 可以找到关于 nvm 的说明。</p>
<h3 id="通过-nvm-来安装-Node"><a href="#通过-nvm-来安装-Node" class="headerlink" title="通过 nvm 来安装 Node"></a>通过 nvm 来安装 Node</h3><p>安装 nvm 并使用 nvm 来安装 Node 的流程如下：</p>
<ul>
<li>使用下面指令安装  nvm</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</div></pre></td></tr></table></figure>
<ul>
<li>重启终端或者使用 source 指令重新加载终端配置<br>在终端输入 <code>nvm</code> 会显示 nvm 支持的指令，其中需要我们注意的我使用红色箭头标识出来了；</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-0d5cbfada8ff578a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>使用指令 <code>nvm ls-remote</code> 查看当前可以安装的 node 版本<br>在我写这篇时最新的版本是 v8.1.3，长期支持版本 LTS 是 v6.11.0。如果你追求新版本体验的话可以安装最新的版本，如果希望使用一个稳定的版本就安装 LTS 版本</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-e070b147ca04cd48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>使用指令 <code>nvm install vx.x.x</code> 安装指定的 Node 版本<br>这里我安装的是稳定的 <code>v6.11.0</code> 版本，使用 <code>node -v</code> 就可以看到安装的 Node 具体版本。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-247790b94d98c58c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>到此我们就成功安装了 Node ，但是关于 Node 的事情还没有结束，我们需要升级下 npm 的版本。</p>
<h3 id="npm-的简介与升级"><a href="#npm-的简介与升级" class="headerlink" title="npm 的简介与升级"></a>npm 的简介与升级</h3><p>在 Node 安装完成后会提示 <code>Now using node v6.11.0 (npm v3.10.10)</code> ，可以看到这里不仅仅存在一个 Node 的版本还有 npm 的版本，那么 npm 是啥呢？</p>
<p> npm 是 Node 的模块管理器，它的用途和前面提到的 <code>Homebrew</code> 非常一致，都是软件的管理器，方便我们安装自己想要的各种软件。有了 npm 我们就可以快速的安装一个他人已经写好的 Node 模块，从而减少我们的开发时间，用现成的轮子而不是自己从头开始写。</p>
<p>在 npm 的<a href="https://www.npmjs.com/" target="_blank" rel="external">官网</a>中我们可以搜索到各种他人已经写好的 node 模块，通过 npm 安装模块也十分简单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装 react 模块</span></div><div class="line">npm install react </div><div class="line"></div><div class="line"><span class="comment"># 全局安装 react-native-cli 模块 </span></div><div class="line">npm install -g react-native-cli</div></pre></td></tr></table></figure></p>
<p>这里我只简单列出了2种 <code>install</code> 指令的用法，第二条指令使用 <code>-g</code> 参数，那么这个参数有什么用呢? </p>
<p>npm 安装 node 模块分2种情况：</p>
<ul>
<li>安装在当前目录下<br>比如你在一个空文件夹下执行 <code>npm install</code>执行安装一个模块，你会发现他会在当前文件夹下生产一个 <code>node_modules</code> 文件夹，我们安装的 <code>react</code> 模块就放在这个 <code>node_modules</code> 中，在这种情况下我们就只能在当前路径下才能使用 <code>react</code> 模块。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-f382bc77d87eb71c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>安装在全局<br>使用 <code>-g</code> 参数后会把安装的 node 模块安装在全局上，使用这种方式安装的模块就可以在任意路径下使用了。一般使用这种方式安装的都是使用 node 编写的一些工具，例如我们后面需要安装的 <code>react-native-cli</code></li>
</ul>
<p>通常我们要使用最新的 npm，npm 也是安装在全局的 node 工具模块，所以我们可以使用 npm 去升级 npm，感觉有点拗口啊。</p>
<p>使用下面的指令就可以完成 npm 的升级，升级完成后后可以使用 <code>npm -v</code> 查看升级后的 npm 版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g npm</div></pre></td></tr></table></figure></p>
<p><strong> 注意: 使用 <code>-g</code> 安装的模块是安装在当前 node 版本的目录下的，如果你使用 nvm 切换或者安装新的 node 版本，那么你需要重新在新的 node 下重新安装一次</strong></p>
<h2 id="React-Native-命令行工具-react-native-cli"><a href="#React-Native-命令行工具-react-native-cli" class="headerlink" title="React Native 命令行工具 (react-native-cli)"></a>React Native 命令行工具 (react-native-cli)</h2><p>react-native-cli 的安装前面已经说过，直接使用 npm 安装在全局中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g react-native-cli</div></pre></td></tr></table></figure></p>
<p>安装完成后需要重新打开终端，或者使用 source 加载终端配置。</p>
<h2 id="Watchman"><a href="#Watchman" class="headerlink" title="Watchman"></a>Watchman</h2><p>watchman 是 Facebook 提供的监视文件变化的工具，在其<a href="https://facebook.github.io/watchman/" target="_blank" rel="external">官网</a>上我们可以了解更多信息。</p>
<p>为什么需要安装 watchman呢，在开发 RN 我们会遇到这样的情况，第一次打开一个RN 过程时会等待很长时间，我们可以在终端中看到下面的这样的进度条：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-d0736dd5bdcdf2f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个时候终端起的 node server 正在将我们写的 RN 代码打包成一个单独的文件，由于使用了很多 node 模块，所以这个打包的过程会需要读取非常多的文件。</p>
<p>一旦我们修改了项目的代码就需要重新打包一次，如果没有 watchman 这类监视文件改动的工具，我们就只能重新把所有的文件<br> build 一次，这个时间就非常难接受了。而 watchman 的存在可以让本地的 server 知道哪些文件发生了改动，那么我们只需要把这个文件的部分重新打包即可，这个时间就非常快了。</p>
<p>watchman 使用 brew 安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install watchman</div></pre></td></tr></table></figure></p>
<p><strong> 注意不要使用 npm 来安装 watchman，如果你在本地 server上看到下面的错误，很大的可能就是你的 watchman 是使用 npm 安装的，而这个 watchman 并不是我们想要的。请通过 <code>npm uninstall  watchman  -g</code> 卸载后重新使用 brew 来安装。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-4bed188fc24e51bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>至此 RN 的开发环境就搭建完成，剩下的就是 IDE 的一些设置了，这里推荐使用 Visual Studio Code (VS Code)。VS Code 是微软推出的一款开源免费的编辑器，我们可以在他的<a href="https://code.visualstudio.com/" target="_blank" rel="external">官网</a> 上下载安装。</p>
<h3 id="修改VS-Code语言"><a href="#修改VS-Code语言" class="headerlink" title="修改VS Code语言"></a>修改VS Code语言</h3><p>VS Code 默认使用的是系统的语言，如果你希望切换到英文界面可以使用下面的方式：</p>
<p>快捷键 <code>⌘(Command)+⇧(Shift)+p</code>，打开命令面板，输入 <code>language</code>，选择<code>配置语言 (Configure Language)</code>，<code>↩回车</code><br><img src="http://upload-images.jianshu.io/upload_images/522747-8cf76340055e412f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>修改 <code>locale</code> 为 <code>en</code> ，重启后则为英文，如果需要使用中文则重新设置为 <code>zh-cn</code><br><img src="http://upload-images.jianshu.io/upload_images/522747-7347258953625993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="安装终端-code-命令"><a href="#安装终端-code-命令" class="headerlink" title="安装终端 code 命令"></a>安装终端 <code>code</code> 命令</h3><p>快捷键 <code>⌘(Command)+⇧(Shift)+p</code>，打开命令面板，输入<code>shell</code>，选择 <code>在PATH 中安装 &quot;code&quot; 命令 (Install &#39;code&#39; command in PATH)</code>，<code>↩回车</code><br><img src="http://upload-images.jianshu.io/upload_images/522747-6cbff650ce86eb02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>重启终端后我们就在终端中使用指令 <code>code</code> 来打开工程或者单个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打开当前目录</span></div><div class="line">code . </div><div class="line"></div><div class="line"><span class="comment"># 打开 1.txt 文件</span></div><div class="line">code 1.txt</div></pre></td></tr></table></figure>
<h3 id="颜色主题"><a href="#颜色主题" class="headerlink" title="颜色主题"></a>颜色主题</h3><p>快捷键 <code>⌘(Command)+⇧(Shift)+p</code>，打开命令面板，输入<code>theme</code>，选择 <code>颜色主题 (Color Theme)</code>，<code>↩回车</code><br><img src="http://upload-images.jianshu.io/upload_images/522747-905e76d5af92e048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里推荐 Monokai 主题色<br><img src="http://upload-images.jianshu.io/upload_images/522747-f3e6145b27b78366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="扩展插件的安装"><a href="#扩展插件的安装" class="headerlink" title="扩展插件的安装"></a>扩展插件的安装</h3><p>点击下图箭头所示的地方可以安装我们需要的插件，推荐大家安装图示的插件。<br><img src="http://upload-images.jianshu.io/upload_images/522747-c6e0d1f2303ce9af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一些插件会需要额外的配置，下面会列举出来</p>
<h4 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h4><p>ESLint 是 JavaScript 和 JSX 的检查工具，可以规范代码，发现编写代码工程中的问题，想了解更多细节可以去<a href="http://eslint.cn/" target="_blank" rel="external">中文官网</a>查看，为了正常的使用 ESLint 插件我们需要通过 npm 安装一些必备的模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装 ESLint</span></div><div class="line">npm install  -g eslint </div><div class="line"></div><div class="line"><span class="comment"># 安装 ESLint 的 react 支持</span></div><div class="line">npm install  -g eslint-plugin-react</div><div class="line"></div><div class="line"><span class="comment"># 安装 ESLint 的 react native 支持</span></div><div class="line">npm install  -g eslint-plugin-react-native</div></pre></td></tr></table></figure>
<p>使用  ESLint 之后就可以关闭 VS Code 自带的 TypeScript 检查了，使用快捷键 <code>⌘(Command)+,</code> 打开配置配置文件，设置 <code>javascript.validate.enable</code> 属性为 <code>false</code> 即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-1d17222a0cc16b38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>每个项目都需要我们配置ESLint，为了生成 ESLint 的配置文件，我们可以在终端中使用 <code>eslint --init</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-218cb62128e3ceb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>或者 快捷键 <code>⌘(Command)+⇧(Shift)+p</code>，打开命令面板，输入<code>eslint</code>，选择<code>Create &#39;.eslintrc.json&#39; File</code>，个人是推荐这种方式哈~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-ca68f14cbaf80dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>但是生成的 <code>.eslintrc.json</code> 的配置还是不够完善，可以看到连默认的demo都会提示一些警告，而这些警告显然是不应该出现的，这就是因为 <code>.eslintrc.json</code> 对 RN 的配置还不够完善。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-9b46d8c17257542e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>为了让 ESLint 更贴合 RN 的代码，这就需要使用到我们前面安装的 ESLint react 支持 和 react native 支持，在 <code>.eslintrc.json</code> 中添加如下配置，这个时候我们再回来看代码就不会出现这些错误的警告了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/522747-ed3a5c4fba0d0a13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上面的配置图中只列出了基本的一些配置，如果想了解更多可以点击这查看 <a href="https://github.com/yannickcr/eslint-plugin-react" target="_blank" rel="external">ESLint react 支持</a> 和 <a href="https://github.com/intellicode/eslint-plugin-react-native" target="_blank" rel="external">ESLint react native 支持</a></p>
<p>相信有了 ESLint 会让大家的 RN 开发更加规范~</p>
<p>至此一个 RN 的开发环境也就搭建完成了😊~</p>
]]></content>
    
    <summary type="html">
    
      Mac 系统 ReactNative 开发环境的搭建
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Qunar React Native 大规模应用实践</title>
    <link href="http://wenzhao.in/qrn-practice/"/>
    <id>http://wenzhao.in/qrn-practice/</id>
    <published>2017-02-22T12:15:00.000Z</published>
    <updated>2017-02-23T12:57:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>【导读】Qunar React Native（下文简称 QRN）是去哪儿网（Qunar）基于 React Native（下文简称 RN）定制的一套框架，让 RN 用起来更方便快捷，2016 年 3 月上线后已在公司内部大规模应用。透过 QRN 的大规模实践我们可以看到如何更好地去使用 RN。<br><a id="more"></a></p>
<blockquote>
<p>本文首次发表在《程序员》杂志 2017 年 02 月期，如需转载，请与《程序员》联系</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>移动 App 跨平台开发技术因为可以低成本、高效率地完成 App 开发，一直以来都是移动开发的热点。目前常见的跨平台开发技术包括 React Native、Weex 和基于 HTML5 的 Hybrid 框架。Qunar 基于 React Native 定制了一套跨平台移动开发框架——Qunar React Native（QRN），QRN 与已有两年历史的 HY（基于 H5 的 Hybrid 方案）一同构成了当前 Qunar 的跨平台开发框架，这两个框架都是由 Qunar 移动架构组 YMFE 推出。</p>
<p>QRN 解决了使用 RN 中的诸多问题，实现了更少的平台差异、更高的开发效率、更好的用户体验，也非常适合像 Qunar 内部这种多个业务隔离的开发体系。结合成熟的离线资源包框架，QRN 页面可以通过热发快速地完成线上 Bug 的修复甚至发布新页面。目前 Qunar 内部已经有大量的业务上线基于 QRN 的页面，这其中也包括了许多核心的业务流程和日均千万 PV 的页面。</p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Qunar 从 2009 年率先开始无线业务至今，移动客户端一直承担着大量的业务需求。2014、2015 年正是 Qunar 在移动端发力、业务增长凶猛的关键时期，去哪儿旅行 App 的页面也与日俱增，2015 年底 iOS 端 App 大小一度超过 110MB。由于 App Store 的限制，超过 100MB 的 App 只能在 Wi-Fi 下才能下载，这就导致了用户期望定机票、酒店时不能使用 3G/4G 网络随时下载去哪儿旅行客户端，因此当时一个迫切的需求就是减少 App 的大小。</p>
<p>缩减 App 包大小的常见思路是去除冗余的业务、优化图片资源等，但是这样依然很难将 App 的大小减少到 100MB 以下。而从根本上减少 App 大小就需要减少 Native 的页面，删减业务显然不是一个可行的方案，这就要求我们将页面做成可以动态化配置。</p>
<p>在 QRN 之前，Qunar 内部一直存在由我们团队推出的一套可以支持动态化配置的跨平台 App 开发框架——HY <a href="http://ued.qunar.com/hy2/" target="_blank" rel="external">(点击查看更多详情)</a>。HY 是基于 HTML5 的 Hybrid 开发框架，在 Qunar App 中已经有大量的业务使用该方案开发。但是 HTML5 的解决方案存在体验和性能两方面的问题，表现为基于 HY 开发的页面很难达到一个原生的用户体验，在低端 Android 机上体验差，这在一些复杂的动画场景中尤为明显。这些问题其实是 HTML5 方案的基因所决定，因此为了减少 App 的大小我们迫切需要一个新的支持动态化配置的跨平台 App 开发框架。</p>
<p>经过一系列的调研和讨论后，我们决定尝试使用 Facebook 开源的 React Native 作为新的跨平台移动开发框架，这是因为 RN 具有以下特性：</p>
<ol>
<li>支持动态化：RN 的页面逻辑使用 JavaScript（下文简称 JS）来控制，因此我们可以做到动态发布。</li>
<li>跨平台性：RN 本身是支持 iOS 和 Android 两个平台的开发。同时由于其页面开发方式是完全 Web 化的 JS 和 React，这就让 RN 的 Web 端实现成为可能（React Web 就是 QRN 的 Web 端实现），因此 RN 完全可以做到一套代码三端运行。</li>
<li>Native 的用户体验：RN 页面使用的是 Native 的原生组件，具有更强的可定制性，完全可以做到一个 Native 的用户体验。</li>
</ol>
<p>为了验证 RN 的技术细节，2015 年 12 月我们在 Qunar 的一个热门独立客户端“去哪儿睡”上线了基于 RN 开发的酒店用户点评页，其中包括相册的选取界面都是用 RN 来完成（如图 1 所示），该项目同时上线了 iOS 和 Android，页面的整体效果超过预期，这也让我们坚信 React Native 是完全可以作为一个新的跨平台开发框架。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/588967520324d.jpg" width="500"><br></center>

<center>图 1 “去哪儿睡”客户端酒店用户点评页面</center>

<p>在上线去哪儿睡的酒店点评页的过程中，我们也发现了很多 RN 存在的问题，比如部分 RN 组件因为使用的是 Native 的组件所以还存在平台差异、打开 RN 页面时需要一个较长的加载时间等。为了解决这些问题，我们花了 3 个月的时间基于 RN 定制了一套更快、更好、更统一的跨平台开发框架 QRN。</p>
<h2 id="大规模应用现状"><a href="#大规模应用现状" class="headerlink" title="大规模应用现状"></a>大规模应用现状</h2><p>2016 年 3 月我们上线了第一个基于 QRN 的页面：去哪儿旅行 iOS 客户端的酒店首页。在之后的几个月中我们上线了大量基于 QRN 开发的项目，到 2016 年 10 月在去哪儿旅行客户端中已有超过 20 个 QRN 项目，其中有 14 个是同时上线了 iOS 和 Android。平均每个项目有 8 个以上的页面，在此之中，酒店一个 QRN 项目就有多达 20 个页面。</p>
<p>在去哪儿旅行客户端中首页的酒店（仅 iOS）、客栈名宿、金融理财的一级入口均为 QRN 页面。不仅如此，对于核心业务流程，例如订单列表页、订单详情页、用户登录页面也都替换为了 QRN 页面（见图 2），这其中包含了很多日均千万 PV 的页面。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/5889676f078e1.jpg" width="400"><br></center>

<center>图 2  QRN 页面替换</center>

<h2 id="QRN-的架构特点"><a href="#QRN-的架构特点" class="headerlink" title="QRN 的架构特点"></a>QRN 的架构特点</h2><p>QRN 在去哪儿内部大规模的应用与其架构密不可分，在设计 QRN 框架时我们主要考虑了下面三点：</p>
<ol>
<li>业务使用的便利性：部分 RN 组件，比如 Switch、Picker 等并没有做到 iOS、Android 两端的 UI 风格统一，而在 Qunar 移动开发中要求两个平台具有一致的 UI 风格，因此为了保证业务使用的便利性，我们需要进一步抹平平台差异。</li>
<li>与现有页面的共存：在 Qunar 移动端中不仅仅存在 Native 页面，还存在着大量 HY 页面，怎么和这些现有页面进行共存也是我们设计 QRN 所需考虑的问题。</li>
<li>支持热发更新：RN 是一个支持动态化的移动 App 开发框架，因此我们需要考虑设计一个完善的热发更新机制来实现 QRN 页面的 bugfix 甚至提供上线新页面。<br>那么，我们是怎么做的呢？</li>
</ol>
<h3 id="进一步抹平平台差异"><a href="#进一步抹平平台差异" class="headerlink" title="进一步抹平平台差异"></a>进一步抹平平台差异</h3><p>RN 的 Switch 使用的是 iOS 和 Android 各自平台的 UI 风格（如图 3 所示），这在使用时极为不便。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/58896792d356c.jpg" width="500"><br></center><br><center>图 3  React Native 的 Switch 两端 UI 风格对比</center>

<p>在 QRN 中我们提供了 iOS 和 Android 统一的 UI 风格，方便业务使用（如图 4 所示），对于其他不统一的基础 UI 组件，我们都在 Android 上基于 iOS 风格重新实现，保证了两个平台的 UI 统一。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/588967af5ee09.jpg" width="500"><br></center>

<center>图 4  QRN 中统一的 Switch UI 风格</center>

<p>同时，我们也使用 JS 实现了一些常见的外部 UI 组件，例如图 5 中支持侧滑操作的 ListView 和日历等组件。使用 JS 实现的组件具有很强的跨平台性，如果这些 UI 组件出现 Bug，我们也可以通过热发更新快速修复，其成本远低于修复一个 Native 的组件（从<a href="http://ued.qunar.com/qrn/extraUI.html" target="_blank" rel="external">http://ued.qunar.com/qrn/extraUI.html</a> 可查看更多的 QRN 外部 JS UI 组件）。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/588967cd4a88c.jpg" width="500"><br></center>

<center>图 5  支持侧滑操作的 ListView 和日历组件演示</center>

<p>除了 UI 上的不同，iOS 和 Android 平台的差异还体现在其他地方，其中一个不同点就是 App 状态栏。在 iOS 上从 iOS 7 开始就支持沉浸式状态栏，且高度均为 20，但是 Android 上由于系统版本和机型的不同，是否支持沉浸式状态栏、状态栏高度这些属性在写 RN 页面时都需要关注，但 RN 并没有提供一个统一的 API 去获取。对于这些差异，在 QRN 中我们都提供了统一的 API 方便业务在写 QRN 页面时可以直接获取，从而无需区分平台。</p>
<p>通过这些方式我们真正做到了跨平台性，去哪儿旅行客户端首页的客栈名宿页面同时上线了 iOS 和 Android，其 JavaScript 代码只有 6 处 Platform 进行平台的判断，而其源于需要和 iOS、Android 现有的 Native 页面进行交互，本身两个平台的 Native 页面进行数据传递的 Scheme 会存在差异，所以需要进行平台的判断。可以说使用 QRN 进行页面的开发完全可以做到不需要平台代码的判断，一套代码同时运行在两个平台上。</p>
<h3 id="JS-Bundle-的拆分"><a href="#JS-Bundle-的拆分" class="headerlink" title="JS Bundle 的拆分"></a>JS Bundle 的拆分</h3><p>RN 中最终 pack 出来的 JS Bundle 文件不仅仅包含了业务的页面 JS 逻辑，还包含了 RN 组件和其框架的 JS。在 QRN 中，我们把 JS Bundle 文件拆分成了 QRN 的框架 JS 和业务 JS（如图 6 所示），在拆分后所有的业务共用一份 QRN 框架 JS，这样每个业务只需提供自己的业务 JS，通过它们的拆分，有效地减少了 JSBundle 的大小，同时也方便了后续的预加载和缓存。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/588967ebc2554.jpg" width="350"><br></center><br><center>图 6  拆分 JS Bundle</center>

<h3 id="QRN-的预加载和缓存"><a href="#QRN-的预加载和缓存" class="headerlink" title="QRN 的预加载和缓存"></a>QRN 的预加载和缓存</h3><p>RN 中创建 RCTRootView（RN 页面渲染的 View）之后会有一个白屏的时间等待 RN 环境的初始化和加载 JS Bundle 文件，这个时间会接近 1s。在 QRN 中，我们提供一个异步获取 RCTRootView 的方法，获取的 RCTRootView 已经完成了 RN 环境的初始化，并已加载完 QRN 的框架 JS 和业务 JS，这时可以直接开始渲染。</p>
<p>为了减少 QRN 中获取 View 的时间，我们进行了 RN 环境的预加载和缓存。所谓预加载就是提前初始化好一个已经加载 QRN 框架 JS 的 RN 环境，这样就只需要去加载业务 JS，可以缩短最少 200ms 的等待时间。缓存指的是我们会缓存一个业务已经加载好的 RN 环境，当下次进入这个业务时就可以直接开始页面的渲染。</p>
<p>在 QRN 中我们给每个业务提供了一个独立的 RN 环境，保证了业务的独立性，当一个业务的 JS 代码出现问题时并不会影响其他业务。这种 QRN 业务完全解耦的方式非常适合类似于 Qunar 这种业务隔离的情况。</p>
<h3 id="成熟的离线资源包框架"><a href="#成熟的离线资源包框架" class="headerlink" title="成熟的离线资源包框架"></a>成熟的离线资源包框架</h3><p>在 QRN 中，业务 JS 是线上资源，为了减少用户下载时间，我们给 QRN 添加了离线资源包的支持，如果其中有对应网络请求的网络资源，那么请求会直接返回本地离线资源包中的文件，这个时间和读取本地文件一样，因此有效减少了网络请求业务 JS 的时间。同时对于业务使用的图片等资源，我们也会放在离线资源包中加快资源打开速度。离线资源包的使用不仅仅减少了下载业务 JS 的时间，而且让 QRN 页面可以在离线情况下打开，更像一个 Native 的页面。</p>
<p>目前所有的动态化移动开发框架都需要离线资源包的支持来减少资源加载时间，每个公司应该都会有自己的一套实现机制，QRN 使用的离线资源包已经在 HY 中应用多年，其基于 BSDiff 的差分更新机制和智能化的更新策略可以在保证节省用户流量的同时拥有极高的资源包更新率。一个 1.2MB 的资源包，其更新时仅仅需要下载不到 1KB 的补丁。该离线资源包框架适合加速移动开发中的各种网络资源请求，引入框架不需要对已有的网络请求代码做任何修改，整个资源包框架对于资源请求方是无感知的。</p>
<h3 id="自定义-IconFont（图标字体）的支持"><a href="#自定义-IconFont（图标字体）的支持" class="headerlink" title="自定义 IconFont（图标字体）的支持"></a>自定义 IconFont（图标字体）的支持</h3><p>在 QRN 中我们添加了自定义 IconFont 的支持，可以使用 IconFont 来作为图标。业务只需要在 JS 代码中配置需要加载的 IconFont 就可以自动完成字体的添加，整个过程无需编写任何 Native 代码。与使用图片做图标相比，IconFont 作为矢量图更清晰、更轻量也更灵活。</p>
<p>图 7 所示的去哪儿旅行客栈名宿页面中的住宿类型图标就是基于 IconFont 实现，通过设置字体颜色、阴影等属性就可以控制图标的效果，如果使用图片的话就得为每个不同的大小和效果准备不同的文件。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/5889680d63d9f.jpg" width="450"><br></center>

<center>图 7  基于 IconFont 实现的住宿类型图标</center>

<p>目前我们团队已经开源了 <a href="http://yicon.ymfe.tech/" target="_blank" rel="external"><code>YIcon</code></a> ，一个集图标展示、上传、使用于一身的图标平台，如果你希望在前端、移动端项目上使用 <code>IconFont</code> 来替换图片图标的话，欢迎使用我们提供的 IconFont 平台。</p>
<h3 id="无埋点统计方案支持"><a href="#无埋点统计方案支持" class="headerlink" title="无埋点统计方案支持"></a>无埋点统计方案支持</h3><p>QRN 中增加了对 Qunar 无埋点统计方案 <a href="http://qav.qunar.com/static/html/index.html" target="_blank" rel="external">QAV</a> 的支持，通过修改 RN 框架，我们做到了 JS 代码无需任何修改就可以统计用户的点击、跳转数据，结合 QAV 提供的用户细查、页面流量分析等多维度的用户分析渠道，让 App 开发者可以洞察用户的行为。而引入这套无埋点方案非常简单，只需将 RN 替换为 QRN 即可，不用对已有的 RN JS 代码做任何的修改。</p>
<h3 id="全新的-ScrollView-和-ListView"><a href="#全新的-ScrollView-和-ListView" class="headerlink" title="全新的 ScrollView 和 ListView"></a>全新的 ScrollView 和 ListView</h3><p>ScrollView 和 ListView 是业务最常使用的两个组件，但是 RN 的 ScrollView 和 ListView 的性能和内存占用达不到我们的期望。目前网上有很多开源的优化方案，在 QRN 中我们也设计了一套全新的 ScrollView 和 ListView，可以带来更高的灵活性和更小的内存占用。</p>
<p>QRN 的 ScrollView 与 RN ScrollView 最大的不同在于前者的滚动手势是由 JS 控制，而后者使用的是 Native 的 ScrollView，在 Native 处理了滚动手势后通知 JS ScrollView 滚动到哪个位置，详细对比可见图 8。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/588968307ebfb.jpg" width="500"><br></center>

<center>图 8  QRN ScrollView 与 RN ScrollView 处理对比</center>

<p>因为 RN 中除了 ScrollView 和 ListView 以外，其他组件的用户手势均由 JS 处理，如果使用 QRN ScrollView 则可以保证 RN 页面所有的组件都使用了统一的手势处理机制，从而带来极大的灵活性，让 ScrollView 嵌套 ScrollView 的效果更加自然。</p>
<p>QRN 的 ListView 基于 React 的虚拟 DOM Diff 算法实现了真正意义上的 Cell 复用，图 9 显示了在 iPhone 7 上同样 2000 行数据滑动到底时的内存占用情况，可以看到 QRN 的 ListView 内存占用一直维持在 70MB 以内，而 RN 的 ListView 在滑动过程中内存最高达 1.3GB，最终稳定的内存占用也接近 600MB，显然对于大部分的机型，RN ListView 这样的内存占用会导致 App 闪退。</p>
<center><br>    <img src="http://ipad-cms.csdn.net/cms/attachment/201702/588968f2b93a3.jpg" width="500"><br></center>

<center>图 9  内存占用峰值对比</center>

<p>QRN 的 ListView 与 RN ListView 用法完全一致，一个现有的 RN 项目只需要将 <code>import{ListView}from&#39;react-native&#39;</code>修改为 <code>import{ListView}fromqunar-react-native</code> 即可使用 QRN 的 ListView。</p>
<p>由于 QRN 的 ScrollView 会在 JS 中处理滚动手势，QRN 的 ListView 也会在 JS 中处理 cell 的复用，因此一旦 JS 线程负担过重就会导致页面的卡顿，这也是目前 QRN ScrollView 和 ListView 存在的不足，好在其中大部分都可以通过优化 JS 代码解决。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在大规模应用 QRN 的过程中，我们也遇到了很多问题，主要表现为：</p>
<h3 id="node-modules-依赖问题"><a href="#node-modules-依赖问题" class="headerlink" title="node_modules 依赖问题"></a>node_modules 依赖问题</h3><p>npm 并没有很好地解决模块依赖冲突的问题（关于 npm 处理模块依赖冲突的方式可阅读：<a href="http://www.alloyteam.com/2016/03/master-npm/" target="_blank" rel="external">http://www.alloyteam.com/2016/03/master-npm/</a>）。但是在 RN 中这个情况会变得更加复杂，RN pack 包的逻辑会默认使用第一级目录下的模块，也就是说如果一个模块 A，在第一级目录下安装了版本 A@1，但是另外一个模块 B 依赖了模块 A@2，那么在模块 B 的 <code>node_modules</code> 下会安装模块 A@2，但是 RN pack 出来的 JS Bundle 中只会存在 A@1。</p>
<p>因为 QRN 中进行了框架 JS 和业务 JS 的拆分，而同一个模块只会在框架 JS 和业务 JS 中存在一份，这就导致了我们需要保证不同的业务 pack JS Bundle 时一级目录下 QRN 依赖的模块都是指定版本。目前，我们自定义了一套<a href="http://ued.qunar.com/qrn/qrn_tool.html" target="_blank" rel="external">工具</a>来解决这个问题。</p>
<h3 id="React-Native-开发"><a href="#React-Native-开发" class="headerlink" title="React Native 开发"></a>React Native 开发</h3><p>RN 的开发使用了大量的前端工具，如 JSX、Redux 等。因此，一个前端开发者来开发 RN 时会更容易上手；但是 RN 的开发又需要了解 Native 的布局，这点 Native 开发者会更加熟悉。</p>
<p>目前在 Qunar 内部，同时有前端团队和 Native 开发团队在进行 QRN 页面的开发。在我们看来，RN 的开发是一个全新的开发方式，其既不是传统的前端开发，也不能简单地当作 iOS、Android 开发。相比于前端几十年的开发历史，RN 从公布到现在还不足 2 年，关于 RN 还缺乏足够多的优化技巧与资料，匮乏的高级 RN 开发者其实也阻碍了 RN 的推广与应用，好在这个问题相信会随着越来越多的人学习 RN 开发得到改善。</p>
<h3 id="一直变化的官方版本"><a href="#一直变化的官方版本" class="headerlink" title="一直变化的官方版本"></a>一直变化的官方版本</h3><p>RN 目前还处于变化中，每两周会有一个新版本，从 2017 年开始，RN 的发布周期变为每个月一次，逐渐趋于稳定。版本的频繁更新特别是布局 CSS Layout 的改动，会导致现有的 Flex 布局出现问题。想象一下，一个 Web 页面在一年间要依次兼容 IE6 至 IE10，这显然是需要开发者花费大量精力来处理版本升级所带来的兼容问题。</p>
<p>QRN 在 2016 年 10 月做了一次官方版本的同步，将基于的 RN 版本从 0.20.0 升级到了 0.33.0，升级之后需要业务进行所有页面的回归，主要是要业务解决 Flex 布局的变化可能导致页面显示错误的问题。升级的主要目的是为了解决 0.20.0 中 RN 存在的 Bug，这个过程中发现升级 Base 的 RN 版本会给业务造成负担，后续 QRN 会评估同步 RN 新版本的收益和风险来决定是否升级 Base 的 RN 版本。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>Qunar 一直以来就是以技术驱动的公司，敢于尝试各种新的技术，在 RN 开源后我们团队就一直在探讨 App 中引入 RN 的可行性。目前 QRN 已经在 Qunar 内部大规模应用，这也验证了我们对 RN 的看法：RN 完全可以胜任核心业务页面，虽然和 Native 的页面还存在差距，但是由于其很强的可定制性，因此潜力很大。随着越来越多更熟练的 RN 开发者出现，RN 必将在业界成为一个非常核心的移动跨平台开发方案。后续我们将把 QRN 做成一个 SDK，开放给大家使用，让 RN 的开发变得更加快捷、简单，未来也在计划开源 QRN。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      Qunar React Native 大规模应用实践现状
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
      <category term="QunarReactNative" scheme="http://wenzhao.in/tags/QunarReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Qunar React Native ( QRN ) 首屏加载速度优化</title>
    <link href="http://wenzhao.in/qrn-optimize-load-firstPage/"/>
    <id>http://wenzhao.in/qrn-optimize-load-firstPage/</id>
    <published>2017-01-17T02:15:00.000Z</published>
    <updated>2017-01-19T13:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>React Native ( RN )可以说是目前最火的移动跨平台开发框架，其通过 JavaScript （JS）来开发 iOS、Android 原生应用，因为使用的是 Native 的原生组件，通过 RN 开发的页面可以媲美原生 Native 页面。 Qunar  React  Native ( QRN ) 是 Qunar 移动架构组 ( YMFE ) 基于 RN 深度定制的跨平台移动开发框架，QRN 在框架层面上进一步抹平了 iOS 与 Android 的平台差异，让 RN 的开发变得更加高效。<br><a id="more"></a><br>当我们打开 RN 的 Demo 时可以非常明显的看到在显示 RN 页面之前有一个白屏的过程。为了优化体验，在 QRN 中使用了 Loading 动画对应 RN 中的白屏阶段。当点击进入一个 QRN 页面时我们会先看到 Loading 动画，在 Loading 动画结束后才会进入到 QRN 页面，这个 Loading 动画只会在用户首次进入该页面时出现。但是随着业务 QRN 的页面变得复杂，引入更多工具例如 Redux后，首屏加载的 Loading 动画时间会越来越长，用户体验也会变得更糟。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844822177784.jpg" width="500" title="RN 加载白屏">
<img src="http://ojvik2xpf.bkt.clouddn.com/14844867632251.jpg" width="480" title="QRN 加载Loading">
<p>本文就是为了减少 Loading 动画时间，让 QRN 页面更像一个 Native 页面。首先会介绍 RN 中一些重要概念和 RN 的加载流程，并在这个基础上介绍 QRN 中为了提高打开速度所做的一些工作， 之后会结合这些提出优化 QRN 首屏加载速度的方法，让 Loading 动画的时间变得更短。对于使用 RN 进行开发的朋友也可以通过这些方法减少白屏时间。</p>
<h2 id="RootView-与-Bridge"><a href="#RootView-与-Bridge" class="headerlink" title="RootView  与 Bridge"></a>RootView  与 Bridge</h2><p>RootView  与 Bridge 是 RN 开发中非常重要的两个概念。RN  页面显示的所有 View 都是放置于 RootView 上，RootView 可以理解为 RN 页面的画板，一个 RootView 上同时只能显示一个通过 JS  函数 <code>AppRegistry.registerComponent()</code> 注册的页面。</p>
<p>Bridge 是 RN 中 JS 代码与 Native 代码交互的桥梁， 通过 Bridge JS 代码可以调用 Native 的 API，并在 RootView 上绘制需要显示的 View。可以说 Bridge 是 RN JS 代码的解释器，一个 Ready 状态的 Bridge 包含了 RN Native 环境、JS 环境以及初始化完成的各种 RN 模块和 UI 组件。</p>
<p>在 RN 中每个 RootView 都有与之对应的 Bridge，一个 Bridge 可以对应多个 RootView ，这些多个 RootView 因为共用的一个 Bridge 所以他们其实使用的是同一套 JS 环境，并且支持显示不同的页面。 在 RN 中 RootView 的白屏和 QRN 的 Loading 动画都是在等待其所对应的 Bridge 加载完成。<br><img src="http://ojvik2xpf.bkt.clouddn.com/14844851764837.jpg" width="600"></p>
<h2 id="RN-的加载流程"><a href="#RN-的加载流程" class="headerlink" title="RN 的加载流程"></a>RN 的加载流程</h2><p>在了解 RN 的加载流程之前，我们先看下一个典型的 RN 页面组件的写法。我们会先从 <code>react</code> 和 <code>react-native</code> 中引入所需的基本组件，页面 <code>Page</code> 继承自 <code>Component</code> ，在<code>reder()</code> 函数中我们会返回需要渲染的页面，最后我们会通过 <code>AppRegistry.registerComponent(&#39;Page&#39;, () =&gt; Page)</code> 完成页面的注册。<code>AppRegistry.registerComponent(&#39;Page&#39;, () =&gt; Page)</code> 函数中第一个参数 <code>&#39;Page&#39;</code> 是我们需要注册的组件名称，第二个参数 <code>() =&gt; Page</code> 是一个函数，用来返回对应的页面组件。我们可以使用 <code>AppRegistry.registerComponent()</code> 注册多个页面。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844891074833.jpg" width="500">
<p>这里把 RN 的加载流程简化为 4 个阶段：</p>
<ul>
<li>初始化 RN 环境</li>
<li>下载 JS Bundle</li>
<li>运行 JS Bundle </li>
<li>渲染页面</li>
</ul>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844898534864.jpg" width="500">
<p>初始化 RN 环境主要是完成 Native 环境的初始化，包括创建 Bridge 、 Bridge 中的 JS 环境、RN 模块和各种 UI 组件。JS Bundle 是由 RN 开发工具 pack 出来的 JS 文件，其中不仅仅包含了前面提到的 RN 页面组件的 JS 代码，还有 <code>react</code>、<code>react-native</code> 的JS代码，如果你使用了 <code>Redux</code> ( 这基本上是 RN 开发所必备的)等其他模块，那么他们的代码也会包含在其中。RN 非常简单的 demo 页面minify 之后的 JS  Bundle 文件有接近 700KB，所以 JS Bundle文件的下载时间是需要考虑的。在运行完 JS Bundle 之后，Native 代码会在 JS 环境中执行 <code>AppRegistry.runApplication( moduleName, {})</code>，这个函数才是渲染页面的开始，第一个参数 <code>moduleName</code> 用来告诉JS 环境需要渲染哪一个页面，第二个参数会包含一些页面初始化props，之后用户就可以看到 RootView 上显示的页面了。前面 3 个阶段通常会花费 1s 以上的时间，而渲染页面的时间只需要几十毫秒，不会超过 200ms。因此 RN 页面的白屏主要是为了 <code>AppRegistry.runApplication( )</code>之前的准备工作。</p>
<h2 id="QRN-的加载流程"><a href="#QRN-的加载流程" class="headerlink" title="QRN 的加载流程"></a>QRN 的加载流程</h2><p>在 QRN 中我们将 JS Bundle 拆分为了QRN 框架 JS 和业务 JS 两部分，并在此基础上做了 Bridge 的预加载和缓存用来减少 QRN 页面开始渲染之前的准备时间。</p>
<h3 id="JS-Bundle-的拆分"><a href="#JS-Bundle-的拆分" class="headerlink" title="JS Bundle 的拆分"></a>JS Bundle 的拆分</h3><p>在 RN 的加载流程中提到，JS Bundle 中不仅仅包含 RN 页面组件的 JS 代码，还有 <code>react</code>、<code>react-native</code> 的JS代码以及一些引入的 JS 模块代码。在 QRN 中JS Bundle 被拆分为了 QRN 框架 JS  和业务 JS。QRN 框架 JS 中包含了 <code>react</code>、<code>react-native</code> 以及 QRN 增强框架 <code>Ext</code> 的 JS 代码， 这部分是和业务无关的；业务 JS  是每个业务自己写的一些 JS 代码，包含了页面的布局逻辑、fetch 数据以及处理数据的逻辑等等，如果页面非常简单，那么业务 JS 甚至只需要几KB。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844922442682.jpg" width="400">
<p>经过 JS Bundle 的拆分后，每个业务只需要提供自己的业务 JS，所有业务使用同一份 QRN 框架 JS，这显著减少了 RN 页面需要提供的 JS 代码大小，当 APP 中同时存在多个不同 RN 业务页面时我们只需要提供一份框架 JS。</p>
<p>经过拆分后 QRN 的加载流程在 RN 的基础上变为了 5 个阶段：</p>
<ul>
<li>初始化 RN 环境</li>
<li>加载框架 JS </li>
<li>下载业务 JS </li>
<li>运行业务 JS</li>
<li>渲染页面</li>
</ul>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844924224240.jpg" width="500">
<p>因为框架 JS 是内置到 APP 中的，所以不需要考虑框架 JS 的下载时间，这里直接把读取框架 JS 和运行框架 JS 合并为加载框架 JS 。而对于复杂的 QRN 业务，因为包含多个页面其业务 JS 的大小甚至会超过 1MB，即使是拆分之后我们依然需要考虑下载业务 JS 的时间。</p>
<h3 id="Bridge-的预加载和缓存"><a href="#Bridge-的预加载和缓存" class="headerlink" title="Bridge 的预加载和缓存"></a>Bridge 的预加载和缓存</h3><p>为了进一步提高打开 QRN 页面的速度，在 QRN 中预加载和缓存了 Bridge。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844941527209.jpg" width="500">
<p>因为初始化 RN 环境和加载框架 JS 两个阶段与具体业务是无关的，所以可以预先初始化一个已经加载了框架 JS 的 Bridge，当打开 QRN 页面时只需要执行后面的 3 个阶段。</p>
<p>而对于一个已经成功运行业务 JS 的 Bridge，我们可以缓存下来，当用户再次打开该业务的 QRN 页面时，我们可以使用这个缓存的 Bridge，这样可以直接开始页面的渲染。</p>
<p>在 APP 启动时会创建一个预加载框架 JS 的 Bridge。如果首次打开一个 QRN 业务页面则使用已经预加载框架 JS 的 Bridge 去加载业务 JS ，在成功加载后会缓存这个 Bridge，然后延时创建一个预加载框架 JS 的 Bridge。如果用户再次打开该 QRN 业务的页面则可以直接使用该业务缓存的 Bridge。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844946283915.jpg" width="300">
<p>因此大部分情况下首次打开一个 QRN 页面的加载流程是下图中的情况2。只有非常极端的情况：连续打开 2 个全新 QRN 业务的页面，由于预加载的框架 JS 是延迟创建，因此第二个 QRN 业务会走完全部的 5 个阶段，即情况1。对于已经缓存的 Bridge，用户打开对应的页面时，只需要进行页面的渲染，前面提到过这个时间是非常快的。QRN 中 Loading动画的时间对应下图中的红色方框，因此在 QRN 中 Loading 动画只会存在于首次进入 QRN 业务的时候。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844950632803.jpg" width="600">
<h3 id="QRN-Loading-时间"><a href="#QRN-Loading-时间" class="headerlink" title="QRN  Loading 时间"></a>QRN  Loading 时间</h3><p>QRN 中首屏加载 Loading 动画是 QRN 页面加载流程的前面 4 个阶段，下图是我们基于 iPhone 6 测试出来的时间：</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844955591500.jpg" width="500">
<p>通过预加载， QRN 的加载时间可以减少 300ms 左右。而下载业务 JS 又分为走离线包和走线上两种情况，走离线包指的是网络请求被本地离线资源包所拦截，这个速度和读取本地文件一致，而走线上就是由线上的服务器返回所需要的资源，随着业务 JS 大小增加，这个时间会普遍大于 1s。对于 QRN 已经上线的业务，运行业务 JS 的时间在优化之前普遍会超过 300ms。</p>
<h2 id="QRN-的首屏加载速度优化"><a href="#QRN-的首屏加载速度优化" class="headerlink" title="QRN 的首屏加载速度优化"></a>QRN 的首屏加载速度优化</h2><p>前面已经分析了 QRN 的加载流程和首屏 Loading 中各个阶段的时间，可以看到 QRN 的 Loading 大部分对应下载业务 JS 和运行业务 JS 两个阶段。下载业务 JS  只要保证是走离线包，那么这个时间就非常理想，因此要优化首屏加载时间就只有从运行业务 JS 入手。</p>
<p>那么怎么来减少运行业务 JS 的时间呢，首先看看 RN 是怎么减少运行 JS Bundle 的时间的。</p>
<h3 id="RN-通过-Lazy-requires-优化-JS-Bundle-运行速度"><a href="#RN-通过-Lazy-requires-优化-JS-Bundle-运行速度" class="headerlink" title="RN 通过 Lazy requires 优化 JS Bundle 运行速度"></a>RN 通过 Lazy requires 优化 JS Bundle 运行速度</h3><p>Facebook 有一篇关于 RN 优化的<a href="https://code.facebook.com/posts/895897210527114/" target="_blank" rel="external">Blog</a>，其中提到一个非常关键的点就是: Lazy requires，只有使用一个 JS 模块时才去 require 这个模块，基于这个原理，RN 中使用的各种组件是通过 get 的方式挂在 <code>react-native</code> 上，这样只有用户在使用这个组件例如 <code>Image</code> 时才会 <code>require(&#39;Image&#39;)</code> 这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//  Libraries/react-native/react-native.js</div><div class="line">const ReactNative = &#123;</div><div class="line">  // Components</div><div class="line">  get ActivityIndicator() &#123; return require(&apos;ActivityIndicator&apos;); &#125;,</div><div class="line">  get ActivityIndicatorIOS() &#123; return require(&apos;ActivityIndicatorIOS&apos;); &#125;,</div><div class="line">  get ART() &#123; return require(&apos;ReactNativeART&apos;); &#125;,</div><div class="line">  get DatePickerIOS() &#123; return require(&apos;DatePickerIOS&apos;); &#125;,</div><div class="line">  get DrawerLayoutAndroid() &#123; return require(&apos;DrawerLayoutAndroid&apos;); &#125;,</div><div class="line">  get Image() &#123; return require(&apos;Image&apos;); &#125;,</div><div class="line">  get ImageEditor() &#123; return require(&apos;ImageEditor&apos;); &#125;,</div><div class="line">  get ImageStore() &#123; return require(&apos;ImageStore&apos;); &#125;,</div><div class="line">  get KeyboardAvoidingView() &#123; return require(&apos;KeyboardAvoidingView&apos;); &#125;,</div><div class="line">  get ListView() &#123; return require(&apos;ListView&apos;); &#125;,</div><div class="line">  get MapView() &#123; return require(&apos;MapView&apos;); &#125;,</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> Lazy requires 可以有效的减少运行 JS Bundle 的时间，这是因为 require 一个模块是一个耗时的操作，通过 require 的 polyfills 实现可以看到，require 会初始化一个模块并创建所需的对象，同时初始化一个模块时可能会去 require 其他模块，这种链式的 require 会导致需要花费一个较长的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// packager/react-pakager/src/Resolve/polyfills/require.js</div><div class="line">function require(id) &#123;</div><div class="line">  var mod = modules[id];</div><div class="line">  if (mod &amp;&amp; mod.isInitialized) &#123;</div><div class="line">    return mod.module.exports;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return requireImpl(id);</div><div class="line">&#125;</div><div class="line"></div><div class="line">global.require = require;</div></pre></td></tr></table></figure>
<p> 另一方面我们可以看到 require 函数只会初始化一次该模块，这意味着当我们多次去 require 同一个模块时，其实获取的是同一个对象实例。只有第一次 require 会花费较长时间，后面的多次 require 仅仅是简单的指针赋值，而指针赋值的速度是非常快的。</p>
<h3 id="QRN-框架-JS-提前-require-常用组件"><a href="#QRN-框架-JS-提前-require-常用组件" class="headerlink" title="QRN 框架 JS 提前 require 常用组件"></a>QRN 框架 JS 提前 require 常用组件</h3><p>结合前面对 require 的分析，如果在框架 JS 中提前 require 业务 JS 所需要的组件，那么业务 require 这些组件的时候只会花费非常少的时间，这样就可以显著的减少运行业务 JS 的时间，从而优化首屏加载速度。</p>
<p>按照这个思路我们在 QRN 的框架 JS 中 require 了常用的组件，这其中包括了 <code>View</code> 、<code>Text</code>、<code>Image</code>、<code>ScrollView</code>、<code>ListView</code> 还有 QRN 增强框架 Ext 等等。通过这种方法加载框架 JS 的运行时间增加了200ms，但是业务 JS 的运行时间相应的减少了 200ms，也就是说首屏的加载时间（对应下载业务 JS 和运行业务 JS 两个阶段）相应的也减少了 200ms。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14845605379982.jpg" width="500">
<h3 id="异步-require-页面减少运行业务-JS-时间"><a href="#异步-require-页面减少运行业务-JS-时间" class="headerlink" title="异步 require 页面减少运行业务 JS 时间"></a>异步 require 页面减少运行业务 JS 时间</h3><p>在框架 JS 中提前 require 常用组件可以减少运行业务 JS 的时间，但是对于拥有多个页面的 QRN 业务，例如有20个页面的酒店业务，运行其业务 JS 的时间还是会超过 500ms，对于这种情况就需要通过异步 require 页面的方式来减少运行业务 JS 的时间。</p>
<p>对于常见的 QRN 业务，其入口 JS 如下图所示，通常会先 import 基础组件，然后引入一些工具例如 Redux等，之后会 import 写在其他文件中的页面，最后我们会调用 <code>AppRegistry.registerComponent()</code> 注册页面。import 函数是 ES6 提供的引入组件的新方式，其等效于在文件最前 require 所需的组件。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14845620112962.jpg" width="600">
<p>当运行业务 JS 时，其实初始化了所有的页面，但是一个 QRN 业务的首屏只需要一个页面，因此 require 初始化其他页面所花费的时间也就没有意义。如果可以在运行业务 JS 时不加载页面则会显著的减少运行业务 JS 的时间。由 RN 加载流程可知，<code>AppRegistry.registerComponent()</code> 函数中第二个参数是一个函数，这个函数用来开始渲染时返回所对应的组件,如果把 require 组件写在这个函数中则可以保证在运行业务 JS 时不初始化这个组件，页面的 require 只有在需要渲染这个页面时执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 之前的写法</div><div class="line">const Page1  = require(&apos;Page1&apos;);</div><div class="line">const Page2  = require(&apos;Page2&apos;);</div><div class="line">const Page3  = require(&apos;Page3&apos;);</div><div class="line">const Page4  = require(&apos;Page4&apos;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent(&apos;Page1&apos;, () =&gt; Page1);</div><div class="line">AppRegistry.registerComponent(&apos;Page2&apos;, () =&gt; Page2);</div><div class="line">AppRegistry.registerComponent(&apos;Page3&apos;, () =&gt; Page3);</div><div class="line">AppRegistry.registerComponent(&apos;Page4&apos;, () =&gt; Page4);</div><div class="line"></div><div class="line"></div><div class="line">// 优化的写法</div><div class="line">AppRegistry.registerComponent(&apos;Page1&apos;, () =&gt; require(&apos;Page1&apos;));</div><div class="line">AppRegistry.registerComponent(&apos;Page2&apos;, () =&gt; require(&apos;Page2&apos;));</div><div class="line">AppRegistry.registerComponent(&apos;Page3&apos;, () =&gt; require(&apos;Page3&apos;));</div><div class="line">AppRegistry.registerComponent(&apos;Page4&apos;, () =&gt; require(&apos;Page4&apos;));</div></pre></td></tr></table></figure>
<p>按照这个思路优化后 Hotel 20 个页面的业务JS 加载的时间从 500ms+ 减少到了 112ms，从下面的优化效果中可以看到影响运行 JS 的时间的关键并不是 JS 文件的大小。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14845667355580.jpg" width="400">
<p>对于使用 QRN 增加框架 Ext 开发的业务，从 QRN v1.6.0 开始也提供了类似的注册方法用来优化加载速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> // 之前的写法，直接 require 页面</div><div class="line">require(&apos;./views/hotelList&apos;);</div><div class="line">require(&apos;./views/hotelDetail&apos;);</div><div class="line"> </div><div class="line"> // 优化的写法，第一个参数是 View Name</div><div class="line">Ext.registerView( &apos;HotelList&apos; , ()=&gt; require(&apos;./views/hotelList&apos;) );</div><div class="line">Ext.registerView( &apos;HotelDetail&apos;, ()=&gt; require(&apos;./views/hotelDetail&apos;) );</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 RN 和 QRN 的加载流程，基于 require 组件会耗费时间的认知上提供了优化 QRN 首屏加载速度的方法：在框架 JS 中提前 require 所需的组件和在业务JS 中异步 require 页面。结合这两种方法可以有效的减少首屏的加载时间，让首次进入 QRN 页面的体验更接近 Native 页面。</p>
]]></content>
    
    <summary type="html">
    
      优化 QunarReactNative 首屏加载速度
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
      <category term="QunarReactNative" scheme="http://wenzhao.in/tags/QunarReactNative/"/>
    
  </entry>
  
  <entry>
    <title>textInputMaxLength</title>
    <link href="http://wenzhao.in/RN-TextInput-MaxLength/"/>
    <id>http://wenzhao.in/RN-TextInput-MaxLength/</id>
    <published>2016-05-21T08:29:06.000Z</published>
    <updated>2016-05-21T09:58:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>有业务线的同事提到<code>ReactNative</code>的<code>TextInput</code>组件存在一个bug，中文输入法通过不停点击联想词语可以突破<code>MaxLength</code>属性的限制。于是开始研究修复这个bug。</p>
<h2 id="找出bug的原因"><a href="#找出bug的原因" class="headerlink" title="找出bug的原因"></a>找出bug的原因</h2><p>要修复bug首先需要确认bug出现的条件，测试发现只有使用<code>iOS</code>系统默认的中文<strong>拼音</strong>输入法的联想功能才会突破<code>TextInput</code>的<code>MaxLength</code>限制。其他输入法比如默认的中文笔画输入、搜狗输入法等都不会出现这种情况。   </p>
<p>查看<code>ReactNative</code>的源码发现，限制<code>TextInput</code>输入长度的是在<code>RCTTextFieldManager</code>对每个<code>RCTTextField</code>的下列回调中处理的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)textField:(RCTTextField *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string</div><div class="line">&#123;</div><div class="line">  <span class="comment">// Only allow single keypresses for onKeyPress, pasted text will not be sent.</span></div><div class="line">  <span class="keyword">if</span> (textField.textWasPasted) &#123;</div><div class="line">    textField.textWasPasted = <span class="literal">NO</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    [textField sendKeyValueForString:string];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (textField.maxLength == <span class="literal">nil</span> || [string isEqualToString:<span class="string">@"\n"</span>]) &#123;  <span class="comment">// Make sure forms can be submitted via return</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">NSUInteger</span> allowedLength = textField.maxLength.integerValue - textField.text.length + range.length;</div><div class="line">  <span class="keyword">if</span> (string.length &gt; allowedLength) &#123;</div><div class="line">    <span class="keyword">if</span> (string.length &gt; <span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// Truncate the input string so the result is exactly maxLength</span></div><div class="line">      <span class="built_in">NSString</span> *limitedString = [string substringToIndex:allowedLength];</div><div class="line">      <span class="built_in">NSMutableString</span> *newString = textField.text.mutableCopy;</div><div class="line">      [newString replaceCharactersInRange:range withString:limitedString];</div><div class="line">      textField.text = newString;</div><div class="line">      <span class="comment">// Collapse selection at end of insert to match normal paste behavior</span></div><div class="line">      <span class="built_in">UITextPosition</span> *insertEnd = [textField positionFromPosition:textField.beginningOfDocument</div><div class="line">                                                          offset:(range.location + allowedLength)];</div><div class="line">      textField.selectedTextRange = [textField textRangeFromPosition:insertEnd toPosition:insertEnd];</div><div class="line">      [textField textFieldDidChange];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当使用默认的中文拼音的联想输入的时候，并不会走这个<code>delegate</code>，这个应该是算系统的bug吧，因为测试发现<code>UITextFieldDelegate</code>的所有方法在此时均不会调用，因此使用<code>UITextFieldDelegate</code>并不能去限制默认中文输入法的联想输入长度。   </p>
<p>看来只有从另外的渠道去判断输入的字符是否超过长度，好在这种情况会触发<code>UIControlEventEditingChanged</code>，因此可以在<code>RCTTextField</code>的<code>textFieldDidChange</code>方法中限制输入的长度，如果输入的长度过长则截取。</p>
<h2 id="另外的问题"><a href="#另外的问题" class="headerlink" title="另外的问题"></a>另外的问题</h2><h3 id="拼音输入的长度问题"><a href="#拼音输入的长度问题" class="headerlink" title="拼音输入的长度问题"></a>拼音输入的长度问题</h3><p>在<code>RCTTextField</code>的<code>textFieldDidChange</code>方法中限制输入的长度，可以解决默认中文联想输入过长的问题，但是自己测试就发现了另外的问题😳<br>中文输入的时候打的拼音会被算到<code>text</code>的长度中，这样就导致了如果只能输入一个字符的时候只能打一个拼音字母了😂</p>
<p>网上搜索发现中文的blog对限制<code>UITextField</code>长度的时候都考虑过拼音字母的问题，不会统计拼音字母到字符的长度中。</p>
<h3 id="表情截取的问题😃"><a href="#表情截取的问题😃" class="headerlink" title="表情截取的问题😃"></a>表情截取的问题😃</h3><p>还有个关键的问题就是表情的截取问题，每个表情😄都是占用的2个字符，简单粗暴的截取就会悲剧😱</p>
<p>网上都有很多这种类型的blog，只能说下面的这个方法真好使：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不使用</span></div><div class="line"><span class="keyword">self</span>.text = [<span class="keyword">self</span>.text substringToIndex:_maxLength.unsignedIntegerValue];</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, _maxLength.unsignedIntegerValue);</div><div class="line"><span class="built_in">NSRange</span> textRange = [<span class="keyword">self</span>.text rangeOfComposedCharacterSequencesForRange:range];</div><div class="line"><span class="keyword">self</span>.text = [<span class="keyword">self</span>.text substringWithRange:textRange];</div></pre></td></tr></table></figure></p>
<h3 id="另外的坑"><a href="#另外的坑" class="headerlink" title="另外的坑"></a>另外的坑</h3><p>当然官方的还有大坑，在判断输入字符的是否超过的限制的时候，<code>allowedLength</code>是这样求的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUInteger</span> allowedLength = textField.maxLength.integerValue - textField.text.length + range.length;</div></pre></td></tr></table></figure></p>
<p>这个<code>allowedLength</code>因为是无符号的，所以本来应该是负数的会变的很大很大好么😂<br>如果<code>TextInput</code>默认设置字符的长度超过了<code>MaxLength</code>，然后就可以各种玩耍输入了😂</p>
<p>修这个问题的时候一定得注意如果默认字符超出长度的话得允许删除，不要问我为啥知道😂😂😂</p>
]]></content>
    
    <summary type="html">
    
      修改ReactNative的TextInput组件MaxLength错误
    
    </summary>
    
      <category term="iOS" scheme="http://wenzhao.in/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://wenzhao.in/tags/iOS/"/>
    
      <category term="ReactNative" scheme="http://wenzhao.in/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>折腾Hexo的第一天</title>
    <link href="http://wenzhao.in/first-hexo-day/"/>
    <id>http://wenzhao.in/first-hexo-day/</id>
    <published>2016-05-15T03:55:33.000Z</published>
    <updated>2016-05-15T11:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>hexo</code>支持<code>Markdown</code>，写起来还是蛮顺手的，不过也是各种坑啊@_@   </p>
<p>一个网页首先少不了的就是图片了</p>
<p>图片很好说啊，直接<code>Markdown</code>都有现成的格式引入，<code>hexo</code>用的是<code>marked</code>，这个并不支持设置图片的 size，自己不想去手动压缩图片，于是首先想到就是添加对图片 size 设置的支持。</p>
<h2 id="图片size的支持"><a href="#图片size的支持" class="headerlink" title="图片size的支持"></a>图片size的支持</h2><p>在<code>marked</code>的 <a href="https://github.com/chjj/marked/issues/339" target="_blank" rel="external">issues</a> 中 isiahmeadows 提到了一种去修改<code>Renderer.prototype.image</code> 这个方法，增加对 size 的解析，然后根据 size 解析出来的参数去设置 <code>img</code>标签的<code>width</code>和<code>height</code>。<br>这个思路不错，copy了他的代码，修改了些许的bug😃，然后重启 <code>hexo</code>的server，发现图片的<code>height</code>属性并不能生效😓<br>搜索了下发现是CSS的原因， <code>height</code>被设置为<code>auto</code>了<br>其实通常情况下都不会去更改图片的长宽比，那么只需要设置下图片的<code>width</code>就可以了，于是继续修改<code>markded</code>，修改设置size的数值的顺序，第一个是width第二个是height。同时修改了下该代码中的解析长宽的正则，可以只写<code>width</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原始的</span></div><div class="line"><span class="keyword">var</span> exec = <span class="regexp">/\s=\s*(\d*)\s*x\s*(\d*)\s*$/</span>.exec(href)</div><div class="line"><span class="comment">//修改后的</span></div><div class="line"><span class="keyword">var</span> exec = <span class="regexp">/\s=\s*(\d*)\s*x?\s*(\d*)\s*$/</span>.exec(href)</div></pre></td></tr></table></figure></p>
<p>后面就是开心的只用设置图片的宽度啦~~~<br>赶紧写了第一篇试试，看上去还不错~</p>
<p>然后从首页点进去，发现了另外的一个坑。</p>
<h2 id="图片路径的问题"><a href="#图片路径的问题" class="headerlink" title="图片路径的问题"></a>图片路径的问题</h2><p><code>Markdown</code>中图片的<code>src</code>都是和用户写的一样，于是就出现了一个问题，在首页可以显示的图片到了详情页就不能显示了。<br>如果开启了<code>post_asset_folder</code>的设置，就是详情页可以显示首页不能了。<br>于是继续找文档，发现使用<a href="https://hexo.io/zh-cn/docs/asset-folders.html#相对路径引用的标签插件" target="_blank" rel="external">相对路径引用的标签</a>可以解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img   icon.png 图标 %&#125;</div></pre></td></tr></table></figure></p>
<img src="/first-hexo-day/icon.png" alt="图标" title="图标">
<p>之后就发现一个尴尬的问题，不能设置图片的大小！！！ 前面又白干了。<br>搜索了下发现<code>asset_img</code>并不支持设置图片大小，于是想学着前面修改<code>Markdown</code>的方法去修改。</p>
<p>为了方便自己就只支持<code>width</code>的设置了，于是首先的问题就是参数放在哪？！因为<code>width</code>的设置不是必需的，因此就得考虑如何兼容没有设置该属性的时候。如果放在后面的话，官方的代码逻辑会把后面所有的都当成<code>title</code>，这个逻辑是合理的，因为有的时候我们的<code>title</code>会包含空格。<br><code>width</code>不能放后面的话就放在前面吧，考虑到一个图片的<code>src</code>不会是纯数字的情况，因此可以通过正则判断的方式来判断第一个参数是否是<code>width</code>还是<code>src</code>，于是做了如下的修改：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Asset image tag</div><div class="line"> *</div><div class="line"> * Syntax:</div><div class="line"> *   &#123;% asset_img slug [title]%&#125;</div><div class="line"> */</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> PostAsset = ctx.model(<span class="string">'PostAsset'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">assetImgTag</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> slug = args.shift();</div><div class="line">        <span class="comment">//宽度</span></div><div class="line">        <span class="keyword">var</span> width;</div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^\d+$/</span>.test(slug)) &#123;</div><div class="line">            width = slug;</div><div class="line">            slug = args.shift();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!slug) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> asset = PostAsset.findOne(&#123;</div><div class="line">            <span class="attr">post</span>: <span class="keyword">this</span>._id,</div><div class="line">            <span class="attr">slug</span>: slug</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (!asset) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">// if title is not assigned, set it ''</span></div><div class="line">        <span class="keyword">var</span> title = args.length ? args.join(<span class="string">' '</span>) : <span class="string">''</span>;</div><div class="line">        <span class="comment">// alt always exist</span></div><div class="line">        <span class="keyword">var</span> alt = title || asset.slug;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (width) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'&lt;img src="'</span> + url.resolve(ctx.config.root, asset.path) + <span class="string">'" alt="'</span> + alt + <span class="string">'" title="'</span> + title + <span class="string">'" width="'</span> + width + <span class="string">'"&gt;'</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'&lt;img src="'</span> + url.resolve(ctx.config.root, asset.path) + <span class="string">'" alt="'</span> + alt + <span class="string">'" title="'</span> + title + <span class="string">'"&gt;'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>后面就可以愉快的设置图片的size了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img  20  icon.png 小图标 %&#125;</div></pre></td></tr></table></figure></p>

]]></content>
    
    <summary type="html">
    
      修改hexo支持图片的size
    
    </summary>
    
      <category term="Web" scheme="http://wenzhao.in/categories/Web/"/>
    
    
      <category term="hexo" scheme="http://wenzhao.in/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一篇</title>
    <link href="http://wenzhao.in/hello-world/"/>
    <id>http://wenzhao.in/hello-world/</id>
    <published>2016-05-14T10:30:13.000Z</published>
    <updated>2016-05-15T11:01:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>上午本来准备折腾下 <code>hexo</code>的，结果在刷完6.0的Z3后没有拿稳，然后就悲剧了(＞﹏＜)<br></p>
<p>之后就是拆机评估换屏的难度了，发现z3都开始使用热管了<br></p>
<p>x宝买了个A屏，等收到货后看能否装起来吧。。。</p>
]]></content>
    
    <summary type="html">
    
      大法Z3都没有熬过一年😳
    
    </summary>
    
      <category term="Life" scheme="http://wenzhao.in/categories/Life/"/>
    
    
      <category term="life" scheme="http://wenzhao.in/tags/life/"/>
    
  </entry>
  
</feed>
