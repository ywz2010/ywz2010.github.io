<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个北漂iOS开发者的web之路"><title>Qunar React Native ( QRN ) 首屏加载速度优化 | 记录生活~</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Qunar React Native ( QRN ) 首屏加载速度优化</h1><a id="logo" href="/.">晓昭</a><p class="description">ywz的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Qunar React Native ( QRN ) 首屏加载速度优化</h1><div class="post-meta">Jan 17, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>React Native ( RN )可以说是目前最火的移动跨平台开发框架，其通过 JavaScript （JS）来开发 iOS、Android 原生应用，因为使用的是 Native 的原生组件，通过 RN 开发的页面可以媲美原生 Native 页面。 Qunar  React  Native ( QRN ) 是 Qunar 移动架构组 ( YMFE ) 基于 RN 深度定制的跨平台移动开发框架，QRN 在框架层面上进一步抹平了 iOS 与 Android 的平台差异，让 RN 的开发变得更加高效。<br><a id="more"></a><br>当我们打开 RN 的 Demo 时可以非常明显的看到在显示 RN 页面之前有一个白屏的过程。为了优化体验，在 QRN 中使用了 Loading 动画对应 RN 中的白屏阶段。当点击进入一个 QRN 页面时我们会先看到 Loading 动画，在 Loading 动画结束后才会进入到 QRN 页面，这个 Loading 动画只会在用户首次进入该页面时出现。但是随着业务 QRN 的页面变得复杂，引入更多工具例如 Redux后，首屏加载的 Loading 动画时间会越来越长，用户体验也会变得更糟。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844822177784.jpg" width="500" title="RN 加载白屏">
<img src="http://ojvik2xpf.bkt.clouddn.com/14844867632251.jpg" width="480" title="QRN 加载Loading">
<p>本文就是为了减少 Loading 动画时间，让 QRN 页面更像一个 Native 页面。首先会介绍 RN 中一些重要概念和 RN 的加载流程，并在这个基础上介绍 QRN 中为了提高打开速度所做的一些工作， 之后会结合这些提出优化 QRN 首屏加载速度的方法，让 Loading 动画的时间变得更短。对于使用 RN 进行开发的朋友也可以通过这些方法减少白屏时间。</p>
<h2 id="RootView-与-Bridge"><a href="#RootView-与-Bridge" class="headerlink" title="RootView  与 Bridge"></a>RootView  与 Bridge</h2><p>RootView  与 Bridge 是 RN 开发中非常重要的两个概念。RN  页面显示的所有 View 都是放置于 RootView 上，RootView 可以理解为 RN 页面的画板，一个 RootView 上同时只能显示一个通过 JS  函数 <code>AppRegistry.registerComponent()</code> 注册的页面。</p>
<p>Bridge 是 RN 中 JS 代码与 Native 代码交互的桥梁， 通过 Bridge JS 代码可以调用 Native 的 API，并在 RootView 上绘制需要显示的 View。可以说 Bridge 是 RN JS 代码的解释器，一个 Ready 状态的 Bridge 包含了 RN Native 环境、JS 环境以及初始化完成的各种 RN 模块和 UI 组件。</p>
<p>在 RN 中每个 RootView 都有与之对应的 Bridge，一个 Bridge 可以对应多个 RootView ，这些多个 RootView 因为共用的一个 Bridge 所以他们其实使用的是同一套 JS 环境，并且支持显示不同的页面。 在 RN 中 RootView 的白屏和 QRN 的 Loading 动画都是在等待其所对应的 Bridge 加载完成。<br><img src="http://ojvik2xpf.bkt.clouddn.com/14844851764837.jpg" width="600"></p>
<h2 id="RN-的加载流程"><a href="#RN-的加载流程" class="headerlink" title="RN 的加载流程"></a>RN 的加载流程</h2><p>在了解 RN 的加载流程之前，我们先看下一个典型的 RN 页面组件的写法。我们会先从 <code>react</code> 和 <code>react-native</code> 中引入所需的基本组件，页面 <code>Page</code> 继承自 <code>Component</code> ，在<code>reder()</code> 函数中我们会返回需要渲染的页面，最后我们会通过 <code>AppRegistry.registerComponent(&#39;Page&#39;, () =&gt; Page)</code> 完成页面的注册。<code>AppRegistry.registerComponent(&#39;Page&#39;, () =&gt; Page)</code> 函数中第一个参数 <code>&#39;Page&#39;</code> 是我们需要注册的组件名称，第二个参数 <code>() =&gt; Page</code> 是一个函数，用来返回对应的页面组件。我们可以使用 <code>AppRegistry.registerComponent()</code> 注册多个页面。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844891074833.jpg" width="500">
<p>这里把 RN 的加载流程简化为 4 个阶段：</p>
<ul>
<li>初始化 RN 环境</li>
<li>下载 JS Bundle</li>
<li>运行 JS Bundle </li>
<li>渲染页面</li>
</ul>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844898534864.jpg" width="500">
<p>初始化 RN 环境主要是完成 Native 环境的初始化，包括创建 Bridge 、 Bridge 中的 JS 环境、RN 模块和各种 UI 组件。JS Bundle 是由 RN 开发工具 pack 出来的 JS 文件，其中不仅仅包含了前面提到的 RN 页面组件的 JS 代码，还有 <code>react</code>、<code>react-native</code> 的JS代码，如果你使用了 <code>Redux</code> ( 这基本上是 RN 开发所必备的)等其他模块，那么他们的代码也会包含在其中。RN 非常简单的 demo 页面minify 之后的 JS  Bundle 文件有接近 700KB，所以 JS Bundle文件的下载时间是需要考虑的。在运行完 JS Bundle 之后，Native 代码会在 JS 环境中执行 <code>AppRegistry.runApplication( moduleName, {})</code>，这个函数才是渲染页面的开始，第一个参数 <code>moduleName</code> 用来告诉JS 环境需要渲染哪一个页面，第二个参数会包含一些页面初始化props，之后用户就可以看到 RootView 上显示的页面了。前面 3 个阶段通常会花费 1s 以上的时间，而渲染页面的时间只需要几十毫秒，不会超过 200ms。因此 RN 页面的白屏主要是为了 <code>AppRegistry.runApplication( )</code>之前的准备工作。</p>
<h2 id="QRN-的加载流程"><a href="#QRN-的加载流程" class="headerlink" title="QRN 的加载流程"></a>QRN 的加载流程</h2><p>在 QRN 中我们将 JS Bundle 拆分为了QRN 框架 JS 和业务 JS 两部分，并在此基础上做了 Bridge 的预加载和缓存用来减少 QRN 页面开始渲染之前的准备时间。</p>
<h3 id="JS-Bundle-的拆分"><a href="#JS-Bundle-的拆分" class="headerlink" title="JS Bundle 的拆分"></a>JS Bundle 的拆分</h3><p>在 RN 的加载流程中提到，JS Bundle 中不仅仅包含 RN 页面组件的 JS 代码，还有 <code>react</code>、<code>react-native</code> 的JS代码以及一些引入的 JS 模块代码。在 QRN 中JS Bundle 被拆分为了 QRN 框架 JS  和业务 JS。QRN 框架 JS 中包含了 <code>react</code>、<code>react-native</code> 以及 QRN 增强框架 <code>Ext</code> 的 JS 代码， 这部分是和业务无关的；业务 JS  是每个业务自己写的一些 JS 代码，包含了页面的布局逻辑、fetch 数据以及处理数据的逻辑等等，如果页面非常简单，那么业务 JS 甚至只需要几KB。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844922442682.jpg" width="400">
<p>经过 JS Bundle 的拆分后，每个业务只需要提供自己的业务 JS，所有业务使用同一份 QRN 框架 JS，这显著减少了 RN 页面需要提供的 JS 代码大小，当 APP 中同时存在多个不同 RN 业务页面时我们只需要提供一份框架 JS。</p>
<p>经过拆分后 QRN 的加载流程在 RN 的基础上变为了 5 个阶段：</p>
<ul>
<li>初始化 RN 环境</li>
<li>加载框架 JS </li>
<li>下载业务 JS </li>
<li>运行业务 JS</li>
<li>渲染页面</li>
</ul>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844924224240.jpg" width="500">
<p>因为框架 JS 是内置到 APP 中的，所以不需要考虑框架 JS 的下载时间，这里直接把读取框架 JS 和运行框架 JS 合并为加载框架 JS 。而对于复杂的 QRN 业务，因为包含多个页面其业务 JS 的大小甚至会超过 1MB，即使是拆分之后我们依然需要考虑下载业务 JS 的时间。</p>
<h3 id="Bridge-的预加载和缓存"><a href="#Bridge-的预加载和缓存" class="headerlink" title="Bridge 的预加载和缓存"></a>Bridge 的预加载和缓存</h3><p>为了进一步提高打开 QRN 页面的速度，在 QRN 中预加载和缓存了 Bridge。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844941527209.jpg" width="500">
<p>因为初始化 RN 环境和加载框架 JS 两个阶段与具体业务是无关的，所以可以预先初始化一个已经加载了框架 JS 的 Bridge，当打开 QRN 页面时只需要执行后面的 3 个阶段。</p>
<p>而对于一个已经成功运行业务 JS 的 Bridge，我们可以缓存下来，当用户再次打开该业务的 QRN 页面时，我们可以使用这个缓存的 Bridge，这样可以直接开始页面的渲染。</p>
<p>在 APP 启动时会创建一个预加载框架 JS 的 Bridge。如果首次打开一个 QRN 业务页面则使用已经预加载框架 JS 的 Bridge 去加载业务 JS ，在成功加载后会缓存这个 Bridge，然后延时创建一个预加载框架 JS 的 Bridge。如果用户再次打开该 QRN 业务的页面则可以直接使用该业务缓存的 Bridge。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844946283915.jpg" width="300">
<p>因此大部分情况下首次打开一个 QRN 页面的加载流程是下图中的情况2。只有非常极端的情况：连续打开 2 个全新 QRN 业务的页面，由于预加载的框架 JS 是延迟创建，因此第二个 QRN 业务会走完全部的 5 个阶段，即情况1。对于已经缓存的 Bridge，用户打开对应的页面时，只需要进行页面的渲染，前面提到过这个时间是非常快的。QRN 中 Loading动画的时间对应下图中的红色方框，因此在 QRN 中 Loading 动画只会存在于首次进入 QRN 业务的时候。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844950632803.jpg" width="600">
<h3 id="QRN-Loading-时间"><a href="#QRN-Loading-时间" class="headerlink" title="QRN  Loading 时间"></a>QRN  Loading 时间</h3><p>QRN 中首屏加载 Loading 动画是 QRN 页面加载流程的前面 4 个阶段，下图是我们基于 iPhone 6 测试出来的时间：</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14844955591500.jpg" width="500">
<p>通过预加载， QRN 的加载时间可以减少 300ms 左右。而下载业务 JS 又分为走离线包和走线上两种情况，走离线包指的是网络请求被本地离线资源包所拦截，这个速度和读取本地文件一致，而走线上就是由线上的服务器返回所需要的资源，随着业务 JS 大小增加，这个时间会普遍大于 1s。对于 QRN 已经上线的业务，运行业务 JS 的时间在优化之前普遍会超过 300ms。</p>
<h2 id="QRN-的首屏加载速度优化"><a href="#QRN-的首屏加载速度优化" class="headerlink" title="QRN 的首屏加载速度优化"></a>QRN 的首屏加载速度优化</h2><p>前面已经分析了 QRN 的加载流程和首屏 Loading 中各个阶段的时间，可以看到 QRN 的 Loading 大部分对应下载业务 JS 和运行业务 JS 两个阶段。下载业务 JS  只要保证是走离线包，那么这个时间就非常理想，因此要优化首屏加载时间就只有从运行业务 JS 入手。</p>
<p>那么怎么来减少运行业务 JS 的时间呢，首先看看 RN 是怎么减少运行 JS Bundle 的时间的。</p>
<h3 id="RN-通过-Lazy-requires-优化-JS-Bundle-运行速度"><a href="#RN-通过-Lazy-requires-优化-JS-Bundle-运行速度" class="headerlink" title="RN 通过 Lazy requires 优化 JS Bundle 运行速度"></a>RN 通过 Lazy requires 优化 JS Bundle 运行速度</h3><p>Facebook 有一篇关于 RN 优化的<a href="https://code.facebook.com/posts/895897210527114/" target="_blank" rel="external">Blog</a>，其中提到一个非常关键的点就是: Lazy requires，只有使用一个 JS 模块时才去 require 这个模块，基于这个原理，RN 中使用的各种组件是通过 get 的方式挂在 <code>react-native</code> 上，这样只有用户在使用这个组件例如 <code>Image</code> 时才会 <code>require(&#39;Image&#39;)</code> 这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//  Libraries/react-native/react-native.js</span><br><span class="line">const ReactNative = &#123;</span><br><span class="line">  // Components</span><br><span class="line">  get ActivityIndicator() &#123; return require(&apos;ActivityIndicator&apos;); &#125;,</span><br><span class="line">  get ActivityIndicatorIOS() &#123; return require(&apos;ActivityIndicatorIOS&apos;); &#125;,</span><br><span class="line">  get ART() &#123; return require(&apos;ReactNativeART&apos;); &#125;,</span><br><span class="line">  get DatePickerIOS() &#123; return require(&apos;DatePickerIOS&apos;); &#125;,</span><br><span class="line">  get DrawerLayoutAndroid() &#123; return require(&apos;DrawerLayoutAndroid&apos;); &#125;,</span><br><span class="line">  get Image() &#123; return require(&apos;Image&apos;); &#125;,</span><br><span class="line">  get ImageEditor() &#123; return require(&apos;ImageEditor&apos;); &#125;,</span><br><span class="line">  get ImageStore() &#123; return require(&apos;ImageStore&apos;); &#125;,</span><br><span class="line">  get KeyboardAvoidingView() &#123; return require(&apos;KeyboardAvoidingView&apos;); &#125;,</span><br><span class="line">  get ListView() &#123; return require(&apos;ListView&apos;); &#125;,</span><br><span class="line">  get MapView() &#123; return require(&apos;MapView&apos;); &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Lazy requires 可以有效的减少运行 JS Bundle 的时间，这是因为 require 一个模块是一个耗时的操作，通过 require 的 polyfills 实现可以看到，require 会初始化一个模块并创建所需的对象，同时初始化一个模块时可能会去 require 其他模块，这种链式的 require 会导致需要花费一个较长的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// packager/react-pakager/src/Resolve/polyfills/require.js</span><br><span class="line">function require(id) &#123;</span><br><span class="line">  var mod = modules[id];</span><br><span class="line">  if (mod &amp;&amp; mod.isInitialized) &#123;</span><br><span class="line">    return mod.module.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return requireImpl(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">global.require = require;</span><br></pre></td></tr></table></figure>
<p> 另一方面我们可以看到 require 函数只会初始化一次该模块，这意味着当我们多次去 require 同一个模块时，其实获取的是同一个对象实例。只有第一次 require 会花费较长时间，后面的多次 require 仅仅是简单的指针赋值，而指针赋值的速度是非常快的。</p>
<h3 id="QRN-框架-JS-提前-require-常用组件"><a href="#QRN-框架-JS-提前-require-常用组件" class="headerlink" title="QRN 框架 JS 提前 require 常用组件"></a>QRN 框架 JS 提前 require 常用组件</h3><p>结合前面对 require 的分析，如果在框架 JS 中提前 require 业务 JS 所需要的组件，那么业务 require 这些组件的时候只会花费非常少的时间，这样就可以显著的减少运行业务 JS 的时间，从而优化首屏加载速度。</p>
<p>按照这个思路我们在 QRN 的框架 JS 中 require 了常用的组件，这其中包括了 <code>View</code> 、<code>Text</code>、<code>Image</code>、<code>ScrollView</code>、<code>ListView</code> 还有 QRN 增强框架 Ext 等等。通过这种方法加载框架 JS 的运行时间增加了200ms，但是业务 JS 的运行时间相应的减少了 200ms，也就是说首屏的加载时间（对应下载业务 JS 和运行业务 JS 两个阶段）相应的也减少了 200ms。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14845605379982.jpg" width="500">
<h3 id="异步-require-页面减少运行业务-JS-时间"><a href="#异步-require-页面减少运行业务-JS-时间" class="headerlink" title="异步 require 页面减少运行业务 JS 时间"></a>异步 require 页面减少运行业务 JS 时间</h3><p>在框架 JS 中提前 require 常用组件可以减少运行业务 JS 的时间，但是对于拥有多个页面的 QRN 业务，例如有20个页面的酒店业务，运行其业务 JS 的时间还是会超过 500ms，对于这种情况就需要通过异步 require 页面的方式来减少运行业务 JS 的时间。</p>
<p>对于常见的 QRN 业务，其入口 JS 如下图所示，通常会先 import 基础组件，然后引入一些工具例如 Redux等，之后会 import 写在其他文件中的页面，最后我们会调用 <code>AppRegistry.registerComponent()</code> 注册页面。import 函数是 ES6 提供的引入组件的新方式，其等效于在文件最前 require 所需的组件。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14845620112962.jpg" width="600">
<p>当运行业务 JS 时，其实初始化了所有的页面，但是一个 QRN 业务的首屏只需要一个页面，因此 require 初始化其他页面所花费的时间也就没有意义。如果可以在运行业务 JS 时不加载页面则会显著的减少运行业务 JS 的时间。由 RN 加载流程可知，<code>AppRegistry.registerComponent()</code> 函数中第二个参数是一个函数，这个函数用来开始渲染时返回所对应的组件,如果把 require 组件写在这个函数中则可以保证在运行业务 JS 时不初始化这个组件，页面的 require 只有在需要渲染这个页面时执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 之前的写法</span><br><span class="line">const Page1  = require(&apos;Page1&apos;);</span><br><span class="line">const Page2  = require(&apos;Page2&apos;);</span><br><span class="line">const Page3  = require(&apos;Page3&apos;);</span><br><span class="line">const Page4  = require(&apos;Page4&apos;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;Page1&apos;, () =&gt; Page1);</span><br><span class="line">AppRegistry.registerComponent(&apos;Page2&apos;, () =&gt; Page2);</span><br><span class="line">AppRegistry.registerComponent(&apos;Page3&apos;, () =&gt; Page3);</span><br><span class="line">AppRegistry.registerComponent(&apos;Page4&apos;, () =&gt; Page4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 优化的写法</span><br><span class="line">AppRegistry.registerComponent(&apos;Page1&apos;, () =&gt; require(&apos;Page1&apos;));</span><br><span class="line">AppRegistry.registerComponent(&apos;Page2&apos;, () =&gt; require(&apos;Page2&apos;));</span><br><span class="line">AppRegistry.registerComponent(&apos;Page3&apos;, () =&gt; require(&apos;Page3&apos;));</span><br><span class="line">AppRegistry.registerComponent(&apos;Page4&apos;, () =&gt; require(&apos;Page4&apos;));</span><br></pre></td></tr></table></figure>
<p>按照这个思路优化后 Hotel 20 个页面的业务JS 加载的时间从 500ms+ 减少到了 112ms，从下面的优化效果中可以看到影响运行 JS 的时间的关键并不是 JS 文件的大小。</p>
<img src="http://ojvik2xpf.bkt.clouddn.com/14845667355580.jpg" width="400">
<p>对于使用 QRN 增加框架 Ext 开发的业务，从 QRN v1.6.0 开始也提供了类似的注册方法用来优化加载速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> // 之前的写法，直接 require 页面</span><br><span class="line">require(&apos;./views/hotelList&apos;);</span><br><span class="line">require(&apos;./views/hotelDetail&apos;);</span><br><span class="line"> </span><br><span class="line"> // 优化的写法，第一个参数是 View Name</span><br><span class="line">Ext.registerView( &apos;HotelList&apos; , ()=&gt; require(&apos;./views/hotelList&apos;) );</span><br><span class="line">Ext.registerView( &apos;HotelDetail&apos;, ()=&gt; require(&apos;./views/hotelDetail&apos;) );</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 RN 和 QRN 的加载流程，基于 require 组件会耗费时间的认知上提供了优化 QRN 首屏加载速度的方法：在框架 JS 中提前 require 所需的组件和在业务JS 中异步 require 页面。结合这两种方法可以有效的减少首屏的加载时间，让首次进入 QRN 页面的体验更接近 Native 页面。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.1" async></script><a data-url="http://wenzhao.in/qrn-optimize-load-firstPage/" data-id="ciy4fv2460001gaitx1rw3ich" class="article-share-link">分享到</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/ReactNative/">ReactNative</a><a href="/tags/QunarReactNative/">QunarReactNative</a></div><div class="post-nav"><a href="/RN-TextInput-MaxLength/" class="next">textInputMaxLength</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://wenzhao.in"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/ReactNative/" style="font-size: 15px;">ReactNative</a> <a href="/tags/QunarReactNative/" style="font-size: 15px;">QunarReactNative</a> <a href="/tags/life/" style="font-size: 15px;">life</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/qrn-optimize-load-firstPage/">Qunar React Native ( QRN ) 首屏加载速度优化</a></li><li class="post-list-item"><a class="post-list-link" href="/RN-TextInput-MaxLength/">textInputMaxLength</a></li><li class="post-list-item"><a class="post-list-link" href="/first-hexo-day/">折腾Hexo的第一天</a></li><li class="post-list-item"><a class="post-list-link" href="/hello-world/">第一篇</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">记录生活~.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.1"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>